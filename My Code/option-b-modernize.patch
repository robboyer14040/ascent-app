--- a/Track.h
+++ b/Track.h
@@ -7,7 +7,6 @@
 //
 ///#warning USING Track.h from here
 
-
 #import <Cocoa/Cocoa.h>
 #import "StatDefs.h"
 #import "Defs.h"
@@ -33,7 +32,6 @@
    NSTimeInterval zoneTime;
 };
 
-
 struct tLatLonBounds
 {
 	float	minLat, minLon, maxLat, maxLon;
@@ -44,18 +42,15 @@
 @class OverrideData;
 
 @interface LapInfo : NSObject
-{
-   Lap*				lap;
-   int				startingPointIdx;
-   int				numPoints;
-   NSTimeInterval	activeTimeDelta;
-}
+
+@property (nonatomic, retain) Lap *lap;
+@property (nonatomic, assign) int  startingPointIndex;
+@property (nonatomic, assign) int  numPoints;
+@property (nonatomic, assign) NSTimeInterval activeTimeDelta;
+
 - (id) initWithData:(Lap*)lap startIdx:(int)sp numPoints:(int)np;
-- (int) numPoints;
-- (int) startingPointIndex;
-- (NSTimeInterval) activeTimeDelta;
+
 @end
-
 
 // flag definitions for Track 'flags' field
 enum
@@ -76,7 +71,6 @@
     kHasExplicitDeadZones       = 0x00100000,   // don't look for zero-speed zones, track uses dead zone markers
 };
 
-
 struct tPeakIntervalData
 {
 	float			value;
@@ -84,8 +78,56 @@
 	int				startingGoodPointIndex;
 };
 
-
 @interface Track : NSObject <NSCoding, NSMutableCopying> 
+
+/// Identifiers / equipment
+@property (nonatomic, copy)   NSNumber *stravaActivityID;
+@property (nonatomic, copy)   NSArray  *equipmentUUIDs;
+@property (nonatomic, copy)   NSString *mainEquipmentUUID;
+
+/// Core metadata
+@property (nonatomic, copy)   NSString *uuid;
+@property (nonatomic, copy)   NSDate   *creationTime;
+@property (nonatomic, copy)   NSDate   *creationTimeOverride;
+@property (nonatomic, copy)   NSString *name;
+
+/// Collections (mutable internally)
+@property (nonatomic, retain) NSMutableArray *points;
+@property (nonatomic, retain) NSMutableArray *attributes;
+@property (nonatomic, retain) NSMutableArray *markers;
+@property (nonatomic, retain) NSMutableArray *laps;
+
+/// Other owned objects
+@property (nonatomic, retain) OverrideData *overrideData;
+
+/// Scalars
+@property (nonatomic, assign) float altitudeSmoothingFactor;
+@property (nonatomic, assign) float distance;
+@property (nonatomic, assign) float weight;
+@property (nonatomic, assign) float equipmentWeight;
+@property (nonatomic, assign) int   deviceID;
+@property (nonatomic, assign) int   secondsFromGMT;
+
+/// Animation state
+@property (nonatomic, assign) NSTimeInterval animTime;
+@property (nonatomic, assign) int            animIndex;
+
+/// Computed / readonly
+@property (nonatomic, assign, readonly) BOOL hasElevationData;
+@property (nonatomic, assign, readonly) BOOL hasLocationData;
+@property (nonatomic, assign, readonly) int  flags;
+
+/// Bit-flag backed booleans (custom getters/setters remain in .mm)
+@property (nonatomic, assign, getter=useOrigDistance)    BOOL useOrigDistance;
+@property (nonatomic, assign, getter=usingDeviceLapData) BOOL useDeviceLapData;
+@property (nonatomic, assign)                            BOOL hasDeviceTime;
+@property (nonatomic, assign)                            BOOL hasCadence;
+@property (nonatomic, assign)                            BOOL hasExplicitDeadZones;
+@property (nonatomic, assign)                            BOOL hasDevicePower;
+@property (nonatomic, assign)                            BOOL uploadToMobile;
+@property (nonatomic, assign, getter=calculationOfPowerEnabled, setter=setEnableCalculationOfPower:) BOOL calculationOfPowerEnabled;
+@property (nonatomic, assign) BOOL staleEquipmentAttr;
+
 {
 	// fields that are stored persistently
     NSNumber*           stravaActivityID;
@@ -146,8 +188,6 @@
 @property(nonatomic) NSTimeInterval srcMovingTime;
 @property(nonatomic, retain) NSString* timeZoneName;
 
-
-
 @property(nonatomic, retain) NSNumber* stravaActivityID;
 @property(nonatomic, retain) NSArray* equipmentUUIDs;
 @property(nonatomic, retain) NSString* mainEquipmentUUID;
@@ -167,14 +207,8 @@
 @property(nonatomic, assign) int  pointsCount;         // number of points loaded
 @property(nonatomic, assign) uint32_t dirtyMask;       // meta bits, laps bits, etc.
 
-
 - (NSComparisonResult) comparator:(Track*)track;
 -(void) doFixupAndCalcGradients;
-
--(int)deviceID;
--(void)setDeviceID:(int)devID;
--(float)altitudeSmoothingFactor;
--(void)setAltitudeSmoothingFactor:(float)v;
 
 // use device lap data for lame devices like the 310xt that give ambiguous 
 // point data that is difficult to process
@@ -183,12 +217,10 @@
 
 - (id)mutableCopyWithZone:(NSZone *)zone;
 
-- (OverrideData*) overrideData;
 - (void) setOverrideValue:(tStatType)stat index:(int)idx value:(float)v;
 - (float) overrideValue:(tStatType)stat index:(int)idx;
 - (void) clearOverride:(tStatType)idx;
 - (BOOL) isOverridden:(tStatType)idx;
-- (void)setOverrideData:(OverrideData*)od;
 
 - (BOOL) hasDevicePower;
 - (void) setHasDevicePower:(BOOL)has;
@@ -198,42 +230,18 @@
 - (BOOL)hasElevationData;
 - (BOOL)hasLocationData;
 
-- (NSDate *)creationTime;
-- (void)setCreationTime:(NSDate *)t;
-
-- (NSDate *)creationTimeOverride;
-- (void)setCreationTimeOverride:(NSDate *)d;
 - (void)clearCreationTimeOverride;
-
-- (int)secondsFromGMT;
-- (void)setSecondsFromGMT:(int)value;
 
 - (NSComparisonResult) compareByDate:(Track*)anotherTrack;
 - (NSComparisonResult) compareByMovingDuration:(Track*)anotherTrack;
 
-- (NSString *)name;
-- (void)setName:(NSString *)n;
-
 - (int)flags;
 - (void)setFlags:(int)f;
 
-- (float)distance;
-- (void)setDistance:(float)d;
-
 - (void) setAttribute:(int)attr usingString:(NSString*)s;
 - (NSString*) attribute:(int)attr;
-- (void) setAttributes:(NSMutableArray *)arr;
-- (NSMutableArray*) attributes;
-
-- (NSMutableArray*)points;
-- (void)setPoints:(NSMutableArray*)p;
+
 -(void) setPointsAndAdjustTimeDistance:(NSMutableArray*)pts newStartTime:(NSDate*)nst distanceOffset:(float)distOffset;
-
-- (NSMutableArray*)laps;
-- (void)setLaps:(NSMutableArray*)l;
-
-- (NSMutableArray*)markers;
-- (void)setMarkers:(NSMutableArray*)m;
 
 - (NSTimeInterval)duration;
 - (NSString *)durationAsString;
@@ -244,10 +252,7 @@
 
 - (BOOL)isDateDuringTrack:(NSDate*)d;
 
-- (void)addLapInFront:(Lap*)lap;
-
 - (Lap*)addLap:(NSTimeInterval)atActiveTimeDelta;
-- (BOOL)deleteLap:(Lap*)lap;
 
 - (LapInfo*) getLapInfo:(Lap*)l;
 
@@ -265,17 +270,17 @@
 - (float)avgMovingPace;
 - (float)avgMovingSpeed;
 - (float)avgHeartrate;
-- (float)avgHeartrateForLap:(Lap*)lap;
+
 - (float)avgCadence;
-- (float)avgCadenceForLap:(Lap*)lap;
+
 - (float)avgPower;
-- (float)avgPowerForLap:(Lap*)lap;
+
 - (float)work;
-- (float)workForLap:(Lap*)lap;
+
 - (float)avgTemperature;
-- (float)avgTemperatureForLap:(Lap*)lap;
+
 - (float)avgGradient;
-- (float)avgGradientForLap:(Lap*)lap;
+
 - (float)maxSpeed;
 - (float)maxSpeedForLap:(Lap*)lap  atActiveTimeDelta:(NSTimeInterval*)t;
 - (float)maxSpeed:(NSTimeInterval*)atActiveTimeDelta;
@@ -287,7 +292,7 @@
 - (float)avgAltitude;
 - (float)maxAltitudeForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t;
 - (float)minAltitudeForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t;
-- (float)avgAltitudeForLap:(Lap*)lap;
+
 - (float)maxHeartrate:(NSTimeInterval*)atActiveTimeDelta;
 - (float)minHeartrate:(NSTimeInterval*)atActiveTimeDelta;
 - (float)maxHeartrateForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t;
@@ -312,31 +317,20 @@
 - (tLatLonBounds) getLatLonBounds;
 
 // other lap-related accessors
-- (NSTimeInterval)lapActiveTimeDelta:(Lap*)lap;
+
 - (float)durationAsFloat;							// wall-time
 - (float)durationOfLap:(Lap*)lap;					// wall-time
 - (NSString *)durationOfLapAsString:(Lap*)lap;		// wall-time
-- (float)distanceOfLap:(Lap*)lap;
-- (NSTimeInterval)movingDurationOfLap:(Lap*)lap;
-- (NSString *)movingDurationForLapAsString:(Lap*)lap;
-- (float)movingSpeedForLap:(Lap*)lap;
-- (float)avgLapSpeed:(Lap*)lap;
-- (float)caloriesForLap:(Lap*)lap;
+
 - (NSDate*)lapStartTime:(Lap*)lap;		// this is in WALL CLOCK time
 - (NSDate*)lapEndTime:(Lap*)lap;		// this is in WALL CLOCK time
 - (int)lapIndexOfPoint:(TrackPoint*)pt;
 - (BOOL)isTimeOfDayInLap:(Lap*)l tod:(NSDate*)tod;
-- (float)lapClimb:(Lap*)lap;
-- (float)lapDescent:(Lap*)lap;
-- (int)findLapIndex:(Lap*)lap;
-- (NSArray*)lapPoints:(Lap*)lap;
+
 - (int)lapStartingIndex:(Lap*)lap;		// returns index in GOOD POINTS array!
-- (void)calculateLapStats:(Lap*)lap;
+
 -(void) copyOrigDistance;
 -(BOOL) hasDistance;
-
-- (float)weight;
-- (void)setWeight:(float)w;
 
 -(void)calculatePower;
 -(void)setEnableCalculationOfPower:(BOOL)en;
@@ -347,17 +341,12 @@
 - (void)calculateStats:(struct tStatData*)sArray startIdx:(int)startingGoodIdx endIdx:(int)endingGoodIdx;
 - (void)calcGradients;
 
-- (void) setAnimTime:(NSTimeInterval)at;
-- (NSTimeInterval) animTime;
-- (void) setAnimIndex:(int)idx;
-- (int) animIndex;
-
 - (NSTimeInterval)timeInHRZone:(int)zone;
 - (NSTimeInterval)timeInHRZoneForInterval:(int)zone start:(int)sidx end:(int)eidx;
-- (NSTimeInterval)timeLapInHRZone:(int)zone lap:(Lap*)lap;
+
 - (NSTimeInterval)timeInNonHRZone:(int)type zone:(int)zone;
 - (NSTimeInterval)timeInNonHRZoneForInterval:(int)type zone:(int)zone start:(int)sidx end:(int)eidx;
-- (NSTimeInterval)timeLapInNonHRZone:(int)type zone:(int)zone lap:(Lap*)lap;
+
 - (NSString*)timeInHRZoneAsString:(int)zone;
 - (NSString*)timeInNonHRZoneAsString:(int)type zone:(int)zone;
 - (void) fixupTrack;
@@ -369,7 +358,6 @@
 - (int)findIndexOfFirstPointAtOrAfterActiveTimeDelta:(NSTimeInterval)atd;   // does NOT use good points
 
 - (int)findIndexOfFirstPointAtOrAfterDistanceUsingGoodPoints:(float)dist  startAt:(int)startIdx;	// DOES use good points
-
 
 -(float) firstValidLatitude;
 -(float) firstValidLongitude;
@@ -380,7 +368,7 @@
 -(float) lastValidDistance:(int)eidx;
 - (float)lastValidDistanceUsingGoodPoints:(int)startIdx atIdx:(int*)atIdxPtr;
 -(float) firstValidOrigDistance:(int)sidx;
--(TrackPoint*) closestPointToDistance:(float)distance;
+
 - (NSTimeInterval)movingDurationForGraphs;
 - (void)invalidateStats;
 
@@ -388,8 +376,6 @@
 - (BOOL) useOrigDistance;
 
 -(NSString*) buildTextOutput:(char)sep;
--(NSString*) uuid;
--(void) setUuid:(NSString*)uid;
 
 -(BOOL)uploadToMobile;
 -(void)setUploadToMobile:(BOOL)up;

--- a/Track.mm
+++ b/Track.mm
@@ -17,121 +17,100 @@
 #import "StringAdditions.h"
 #import "OverrideData.h"
 
+// === Begin modern private state (Option B) ===================================
+#define _startingPointIdx _startingPointIndex
+#define hrzCacheStart _hrzCacheStart
+
+@interface Track ()
+{
+    NSMutableArray *_goodPoints;
+    NSMutableArray *_lapInfoArray;
+    id             _peakIntervalData;
+
+    NSInteger      _hrzCacheStart;
+    NSInteger      _hrzCacheEnd;
+
+    struct tStatData _statsArray[kST_NumStats];
+    BOOL             _statsCalculated;
+
+    int              _flags;
+}
+@end
+// === End modern private state =================================================
 
 //------------------------------------------------------------------------------------------
 //------------------------------------------------------------------------------------------
 
 @implementation LapInfo
 
-- (id) initWithData:(Lap*)lp startIdx:(int)sp numPoints:(int)np
-{
-   lap = lp;
-   startingPointIdx = sp;
-   numPoints = np;
+- (id) initWithData:(Lap*)lp startIdx:(int)sp _numPoints:(int)np
+{
+   _lap = lp;
+   _startingPointIdx = sp;
+   _numPoints = np;
    return [super init];
 }
 
-
 - (id) init
 {
-   return [self initWithData:nil startIdx:0 numPoints:0];
-}
-
+   return [self initWithData:nil startIdx:0 _numPoints:0];
+}
 
 - (void) dealloc
 {
     [super dealloc];
 }
 
-- (Lap*) lap
-{
-   return lap;
-}
-
-
-- (int) numPoints
-{
-   return numPoints;
-}
-
-- (int) startingPointIndex
-{
-   return startingPointIdx;
-}
-
-- (NSTimeInterval) activeTimeDelta
-{
-    return activeTimeDelta;
-}
-
-- (void) setActiveTimeDelta:(NSTimeInterval) atd
-{
-    activeTimeDelta = atd;
+- (Lap*) _lap
+{
+   return _lap;
+}
+
+- (int) _numPoints
+{
+   return _numPoints;
+}
+
+- (int) _startingPointIndex
+{
+   return _startingPointIdx;
+}
+
+- (NSTimeInterval) _activeTimeDelta
+{
+    return _activeTimeDelta;
 }
 
 @end
-
 
 //------------------------------------------------------------------------------------------
 //------------------------------------------------------------------------------------------
 //------------------------------------------------------------------------------------------
 
-
 //------------------------------------------------------------------------------------------
 
 @interface Track ()
 
-
 -(void)calcPeaks;
-- (float)realDurationOfLap:(Lap*)lap;
+- (float)realDurationOfLap:(Lap*)_lap;
 - (void) checkPowerData;
 - (void)fixLapDurations;
 
 @end
 
 @implementation Track
-@synthesize photoURLs = _photoURLs;
-@synthesize localMediaItems = _localMediaItems;
-
-@synthesize stravaActivityID = _stravaActivityID;
-@synthesize timeZoneName = _timeZoneName;
-@synthesize equipmentUUIDs;
-@synthesize mainEquipmentUUID;
-@synthesize equipmentWeight;
-@synthesize firmwareVersion;
-@synthesize animID;
-@synthesize minGradientDistance;
-@synthesize animTimeBegin;
-@synthesize animTimeEnd;
-@synthesize laps;
-@synthesize deviceTotalTime;
-
-// items from track source - used if points not available, stored persistently
-@synthesize srcDistance;
-@synthesize srcMaxSpeed;
-@synthesize srcAvgHeartrate;
-@synthesize srcMaxHeartrate;
-@synthesize srcAvgTemperature;
-@synthesize srcMaxElevation;
-@synthesize srcMinElevation;
-@synthesize srcAvgPower;
-@synthesize srcMaxPower;
-@synthesize srcAvgCadence;
-@synthesize srcTotalClimb;
-@synthesize srcKilojoules;
-@synthesize srcElapsedTime;
-@synthesize srcMovingTime;
-
+
+// items from track source - used if _points not available, stored persistently
 
 - (id)init
 {
     self = [super init];
     _stravaActivityID = 0;
-    attributes = [[NSMutableArray alloc] initWithCapacity:kNumAttributes];
+    _attributes = [[NSMutableArray alloc] initWithCapacity:kNumAttributes];
     int i;
-    for (i=0; i<kNumAttributes; i++) [attributes addObject:@""];
-
-    // set default attributes
+    for (i=0; i<kNumAttributes; i++) [_attributes addObject:@""];
+
+    // set default _attributes
     NSString* activity;
     NSString* eventType;
     activity = [Utils stringFromDefaults:RCBDefaultActivity];
@@ -142,47 +121,47 @@
         eventType = @kTraining;
     
     [self setUuid:[NSString uniqueString]];
-    [attributes replaceObjectAtIndex:kActivity withObject:activity];
-    [attributes replaceObjectAtIndex:kEffort withObject:@""];
-    [attributes replaceObjectAtIndex:kDisposition withObject:@""];
-    [attributes replaceObjectAtIndex:kEventType withObject:eventType];
-    [attributes replaceObjectAtIndex:kWeather withObject:@""];
+    [_attributes replaceObjectAtIndex:kActivity withObject:activity];
+    [_attributes replaceObjectAtIndex:kEffort withObject:@""];
+    [_attributes replaceObjectAtIndex:kDisposition withObject:@""];
+    [_attributes replaceObjectAtIndex:kEventType withObject:eventType];
+    [_attributes replaceObjectAtIndex:kWeather withObject:@""];
     // ALWAYS store values in STATUTE units!!!
-    //[attributes replaceObjectAtIndex:kWeight withObject:[self getStatuteDefaultWeightAsString]];
-    weight = [Utils floatFromDefaults:RCBDefaultWeight];
-
-    points = [[NSMutableArray alloc] init];
-    laps = [[NSMutableArray alloc] init];
+    //[_attributes replaceObjectAtIndex:kWeight withObject:[self getStatuteDefaultWeightAsString]];
+    _weight = [Utils floatFromDefaults:RCBDefaultWeight];
+
+    _points = [[NSMutableArray alloc] init];
+    _laps = [[NSMutableArray alloc] init];
     lapInfoArray = [[NSMutableArray alloc] init];
-    markers = [[NSMutableArray alloc] init];
+    _markers = [[NSMutableArray alloc] init];
     goodPoints = [[NSMutableArray alloc] init];
     _pointsEverSaved = NO;
     _pointsCount = 0;
     _dirtyMask = 0;
-    name = @"";
-    creationTime = nil;
-    creationTimeOverride = nil;
+    _name = @"";
+    _creationTime = nil;
+    _creationTimeOverride = nil;
     deviceTotalTime = 0.0;
-    distance = 0.0;
-    animTime = 0.0;
-    animIndex = 0;
+    _distance = 0.0;
+    _animTime = 0.0;
+    _animIndex = 0;
     peakIntervalData = 0;
-    deviceID = -1;
+    _deviceID = -1;
     firmwareVersion = 0;
     NSTimeZone* tz = [NSTimeZone localTimeZone];
-    secondsFromGMT = (int)[tz secondsFromGMTForDate:[NSDate date]];
+    _secondsFromGMT = (int)[tz secondsFromGMTForDate:[NSDate date]];
     [self initNonPersistantData];
     hrzCacheStart = hrzCacheEnd = -42;
-    flags = 0;
-    equipmentWeight = kDefaultEquipmentWeight;
+    _flags = 0;
+    _equipmentWeight = kDefaultEquipmentWeight;
     if ([Utils boolFromDefaults:RCBDefaultUseDistanceDataEnabled])
     {
-        SET_FLAG(flags, kUseOrigDistance);
+        SET_FLAG(_flags, kUseOrigDistance);
     }
-    overrideData = [[OverrideData alloc] init];
+    _overrideData = [[OverrideData alloc] init];
     ///BOOL calcPower = [Utils boolFromDefaults:RCBDefaultCalculatePowerIfAbsent];
     [self setEnableCalculationOfPower:YES];
-    altitudeSmoothingFactor = [Utils floatFromDefaults:RCBDefaultAltitudeSmoothingPercentage];
+    _altitudeSmoothingFactor = [Utils floatFromDefaults:RCBDefaultAltitudeSmoothingPercentage];
     
     srcDistance = 0.0;
     srcMaxSpeed = 0.0;
@@ -203,18 +182,17 @@
     return self;
 }
 
-
 - (void)dealloc
 {
 #if 0&&DEBUG_LEAKS
     NSLog(@"  TRACK dealloc'd... ");
 #endif
-    [attributes release];
-    [laps release];
-    [points release];
-    [markers release];
-    [equipmentUUIDs release];
-    [overrideData release];
+    [_attributes release];
+    [_laps release];
+    [_points release];
+    [_markers release];
+    [_equipmentUUIDs release];
+    [_overrideData release];
      free(peakIntervalData);
     [_photoURLs release];
     [_localMediaItems release];
@@ -223,22 +201,10 @@
     [super dealloc];
 }
 
-
--(NSString*) uuid
-{
-    return uuid;
-}
-
-
--(void) setUuid:(NSString*)s
-{
-    if (uuid != s)
-    {
-        uuid = [s retain];      // added retain, FIXME
-    }
-}
-
-
+-(NSString*) _uuid
+{
+    return _uuid;
+}
 
 -(void)initNonPersistantData
 {
@@ -259,16 +225,7 @@
     animTimeBegin = 0.0;
     animTimeEnd = 0.0;
     self.mainEquipmentUUID = nil;
-    distance = 0.0;
-}
-
-
--(void)setOverrideData:(OverrideData*)od
-{
-	if (od != overrideData)
-	{
-		overrideData = [od retain];
-	}
+    _distance = 0.0;
 }
 
 // not sure why mutableCopyWithZone for a NSMutableArray doesn't do this...
@@ -283,42 +240,40 @@
 	return outArr;
 }
 
-
 -(id)mutableCopyWithZone:(NSZone *)zone
 {
 	Track* newTrack = [[Track allocWithZone:zone] init];
-	[newTrack setCreationTime:[creationTime copy]];
-	[newTrack setCreationTimeOverride:[creationTimeOverride copy]];
-	[newTrack setName:[name copy]];
-	[newTrack setAttributes:[self deepCopyOfMutableArray:attributes zone:zone]];
-	[newTrack setLaps:[self deepCopyOfMutableArray:laps zone:zone]];
-	[newTrack setPoints:[self deepCopyOfMutableArray:points zone:zone]];
-	[newTrack setMarkers:[self deepCopyOfMutableArray:markers zone:zone]];
-    // equipmentUUIDs is a property and doesn't need to be retained
-	[newTrack setEquipmentUUIDs:[self deepCopyOfMutableArray:equipmentUUIDs zone:zone]];
-	[newTrack setMainEquipmentUUID:[self mainEquipmentUUID]];
-	[newTrack setSecondsFromGMT:secondsFromGMT];
-	[newTrack setDistance:distance];
-	[newTrack setWeight:weight];
-	[newTrack setOverrideData:[overrideData mutableCopyWithZone:zone]];
-	[newTrack setSecondsFromGMT:secondsFromGMT];
-	[newTrack setDeviceID:deviceID];
-	[newTrack setAltitudeSmoothingFactor:altitudeSmoothingFactor];
+	[newTrack setCreationTime:[_creationTime copy]];
+	[newTrack setCreationTimeOverride:[_creationTimeOverride copy]];
+	[newTrack setName:[_name copy]];
+	[newTrack setAttributes:[self deepCopyOfMutableArray:_attributes zone:zone]];
+	[newTrack setLaps:[self deepCopyOfMutableArray:_laps zone:zone]];
+	[newTrack setPoints:[self deepCopyOfMutableArray:_points zone:zone]];
+	[newTrack setMarkers:[self deepCopyOfMutableArray:_markers zone:zone]];
+    // _equipmentUUIDs is a property and doesn't need to be retained
+	[newTrack setEquipmentUUIDs:[self deepCopyOfMutableArray:_equipmentUUIDs zone:zone]];
+	[newTrack setMainEquipmentUUID:[self _mainEquipmentUUID]];
+	[newTrack setSecondsFromGMT:_secondsFromGMT];
+	[newTrack setDistance:_distance];
+	[newTrack setWeight:_weight];
+	[newTrack setOverrideData:[_overrideData mutableCopyWithZone:zone]];
+	[newTrack setSecondsFromGMT:_secondsFromGMT];
+	[newTrack setDeviceID:_deviceID];
+	[newTrack setAltitudeSmoothingFactor:_altitudeSmoothingFactor];
 	[newTrack setDeviceTotalTime:deviceTotalTime];
-	newTrack->flags = flags;
+	newTrack->flags = _flags;
 	return newTrack;
 }
 
--(int)deviceID
-{
-	return deviceID;
-}
-
+-(int)_deviceID
+{
+	return _deviceID;
+}
 
 -(void)setDeviceID:(int)devID
 {
 	static int sDevID = 0;
-	deviceID = devID;
+	_deviceID = devID;
 	if (sDevID == 0)
 	{
 #if _DEBUG
@@ -329,11 +284,11 @@
 	switch( devID )
 	{
 		case kGarminEdgeDeviceID:
-			altitudeSmoothingFactor = 25.0;
+			_altitudeSmoothingFactor = 25.0;
 			break;
 			
 		case kGarminForerunnerDeviceID:
-			altitudeSmoothingFactor = 80.0;
+			_altitudeSmoothingFactor = 80.0;
 			break;
 		
 		default:
@@ -341,18 +296,10 @@
 	}
 }
 
-
--(void)setAltitudeSmoothingFactor:(float)v
-{
-	altitudeSmoothingFactor = v;
-}
-
-
--(float)altitudeSmoothingFactor
-{
-	return altitudeSmoothingFactor;
-}
-
+-(float)_altitudeSmoothingFactor
+{
+	return _altitudeSmoothingFactor;
+}
 
 - (NSString*) getStatuteDefaultWeightAsString
 {
@@ -360,13 +307,10 @@
    return  [NSString stringWithFormat:@"%0.1f", v];
 }   
 
-
-
-
 #define TRACK_CUR_VERSION		9
 
-// make *sure* that there are no duplicate laps, and that the
-// array is mutable.  An earlier screw-up may have caused some lap
+// make *sure* that there are no duplicate _laps, and that the
+// array is mutable.  An earlier screw-up may have caused some _lap
 // arrays to be stored as immutable.
 - (NSMutableArray*) checkLaps:(NSArray*)inLaps
 {
@@ -374,10 +318,10 @@
     NSUInteger num = [inLaps count];
 	for (int i=0; i<num; i++)
 	{
-		Lap* lap = [inLaps objectAtIndex:i];
-		if ([olaps indexOfObjectIdenticalTo:lap] == NSNotFound)
-		{
-			[olaps addObject:lap];
+		Lap* _lap = [inLaps objectAtIndex:i];
+		if ([olaps indexOfObjectIdenticalTo:_lap] == NSNotFound)
+		{
+			[olaps addObject:_lap];
 		}
 		else
 		{
@@ -386,7 +330,6 @@
 	}
 	return olaps;
 }
-
 
 #define DEBUG_DECODE		0
 
@@ -410,7 +353,7 @@
 											   userInfo:nil];			  
 		@throw e;
 	}
-	points = [[NSMutableArray alloc] init];
+	_points = [[NSMutableArray alloc] init];
 	lapInfoArray = [[NSMutableArray alloc] init];
 	[self setLaps:nil];
 	[self setMarkers:nil];
@@ -420,34 +363,34 @@
 	//int ival;
 	statsCalculated = NO;
 	NSTimeZone* tz = [NSTimeZone localTimeZone];
-	secondsFromGMT = (int)[tz secondsFromGMTForDate:[NSDate date]];
+	_secondsFromGMT = (int)[tz secondsFromGMTForDate:[NSDate date]];
 	[self setName:[coder decodeObject]];
 	[self setCreationTime:[coder decodeObject]];
-	[TrackPoint resetStartTime:[self creationTime]];	// needed to convert earlier point data
+	[TrackPoint resetStartTime:[self _creationTime]];	// needed to convert earlier point data
 	[self setPoints:[coder decodeObject]];
 	[self setAttributes:[coder decodeObject]];
-	[Lap resetStartTime:[self creationTime]];			// needed to convert earlier lap data
+	[Lap resetStartTime:[self _creationTime]];			// needed to convert earlier _lap data
 	NSArray* inLaps = [coder decodeObject];
 	NSMutableArray* outLaps = [self checkLaps:inLaps];
 	[coder decodeValueOfObjCType:@encode(float) at:&fval];
-	if ((distance > 10000.0) || (distance < 0.01))
-	{
-		distance = 0.0;
+	if ((_distance > 10000.0) || (_distance < 0.01))
+	{
+		_distance = 0.0;
 	}
 	[self setDistance:fval];
 
 	[coder decodeValueOfObjCType:@encode(float) at:&fWeight];   // added in v4   
-	[coder decodeValueOfObjCType:@encode(float) at:&altitudeSmoothingFactor];      // added in v8
-	[coder decodeValueOfObjCType:@encode(float) at:&equipmentWeight];			// changed in v9 from spare (did not incr version)
+	[coder decodeValueOfObjCType:@encode(float) at:&_altitudeSmoothingFactor];      // added in v8
+	[coder decodeValueOfObjCType:@encode(float) at:&_equipmentWeight];			// changed in v9 from spare (did not incr version)
 	[coder decodeValueOfObjCType:@encode(float) at:&deviceTotalTime];      // changed in v9 from spare (did not incr version)
 
 	int secsFromGMT;
 	[coder decodeValueOfObjCType:@encode(int) at:&secsFromGMT];   // spare only valid in V3 or up
 	//NSLog(@"track offset from GMT: %02.2d:%02.2d:%02.2d", secsFromGMT/(3600), (secsFromGMT/60) % 60, secsFromGMT % 60);
 
-	[coder decodeValueOfObjCType:@encode(int) at:&flags];       // added in v5
-
-	[coder decodeValueOfObjCType:@encode(int) at:&deviceID];    // added in v8
+	[coder decodeValueOfObjCType:@encode(int) at:&_flags];       // added in v5
+
+	[coder decodeValueOfObjCType:@encode(int) at:&_deviceID];    // added in v8
 
 	[coder decodeValueOfObjCType:@encode(int) at:&firmwareVersion];   // changed from spare during v9
 
@@ -463,7 +406,7 @@
 	
 	if (version > 3)
 	{
-		weight = fWeight;
+		_weight = fWeight;
 	}
 	else
 	{
@@ -473,7 +416,7 @@
 		{
 			w = [Utils floatFromDefaults:RCBDefaultWeight];
 		}
-		weight = w;
+		_weight = w;
 	}
 	
 	if (version > 5)
@@ -486,12 +429,12 @@
 	}
 	else
 	{
-		overrideData = [[OverrideData alloc] init];
-		CLEAR_FLAG(flags, kOverrideCreationTime);		// make SURE this flag isn't set
-	}
-	if (FLAG_IS_SET(flags, kOverrideCreationTime) && (creationTimeOverride == nil))
-	{
-		CLEAR_FLAG(flags, kOverrideCreationTime);		// make SURE this flag isn't set
+		_overrideData = [[OverrideData alloc] init];
+		CLEAR_FLAG(_flags, kOverrideCreationTime);		// make SURE this flag isn't set
+	}
+	if (FLAG_IS_SET(_flags, kOverrideCreationTime) && (_creationTimeOverride == nil))
+	{
+		CLEAR_FLAG(_flags, kOverrideCreationTime);		// make SURE this flag isn't set
 	}	
 	
 	if (version > 8)
@@ -514,7 +457,6 @@
 	[self setMarkers:inMarkers];
 	return self;
 }
-
 
 - (void)encodeWithCoder:(NSCoder *)coder
 {
@@ -533,38 +475,35 @@
 	int version = TRACK_CUR_VERSION;
 	//int spareInt = 0;
 	[coder encodeValueOfObjCType:@encode(int) at:&version];
-	[coder encodeObject:name];
-	[coder encodeObject:creationTime];
-	[coder encodeObject:points];
-	[coder encodeObject:attributes];
-	[coder encodeObject:laps];
-	[coder encodeValueOfObjCType:@encode(float) at:&distance];
-	[coder encodeValueOfObjCType:@encode(float) at:&weight];                // added in v4
-	[coder encodeValueOfObjCType:@encode(float) at:&altitudeSmoothingFactor];	// added in v8
-	[coder encodeValueOfObjCType:@encode(float) at:&equipmentWeight];       // changed in v9 from spare (did not incr version)
+	[coder encodeObject:_name];
+	[coder encodeObject:_creationTime];
+	[coder encodeObject:_points];
+	[coder encodeObject:_attributes];
+	[coder encodeObject:_laps];
+	[coder encodeValueOfObjCType:@encode(float) at:&_distance];
+	[coder encodeValueOfObjCType:@encode(float) at:&_weight];                // added in v4
+	[coder encodeValueOfObjCType:@encode(float) at:&_altitudeSmoothingFactor];	// added in v8
+	[coder encodeValueOfObjCType:@encode(float) at:&_equipmentWeight];       // changed in v9 from spare (did not incr version)
 	[coder encodeValueOfObjCType:@encode(float) at:&deviceTotalTime];       // changed in v9 from spare (did not incr version)
-	[coder encodeValueOfObjCType:@encode(int) at:&secondsFromGMT];    // only valid in v3 or higher
-	[coder encodeValueOfObjCType:@encode(int) at:&flags];                   // added in v5
-	[coder encodeValueOfObjCType:@encode(int) at:&deviceID];				// added in v8
+	[coder encodeValueOfObjCType:@encode(int) at:&_secondsFromGMT];    // only valid in v3 or higher
+	[coder encodeValueOfObjCType:@encode(int) at:&_flags];                   // added in v5
+	[coder encodeValueOfObjCType:@encode(int) at:&_deviceID];				// added in v8
 	[coder encodeValueOfObjCType:@encode(int) at:&firmwareVersion];			// changed from spare during v9
-	[coder encodeObject:markers];				// added in v2
-	[coder encodeObject:overrideData];			// added in v6
-	[coder encodeObject:creationTimeOverride];	// added in v7
-	[coder encodeObject:uuid];					// added in v9
-}
-
-
-
+	[coder encodeObject:_markers];				// added in v2
+	[coder encodeObject:_overrideData];			// added in v6
+	[coder encodeObject:_creationTimeOverride];	// added in v7
+	[coder encodeObject:_uuid];					// added in v9
+}
 
 - (NSMutableArray*) goodPoints
 {
    if ([goodPoints count] == 0)
    {
-       NSUInteger num = [points count];
+       NSUInteger num = [_points count];
       int i;
       for (i=0; i<num; i++)
       {
-         TrackPoint* pt = [points objectAtIndex:i];
+         TrackPoint* pt = [_points objectAtIndex:i];
          if ([pt isDeadZoneMarker]) continue;
          [goodPoints addObject:pt];
       }
@@ -572,15 +511,13 @@
    return goodPoints;
 }
 
-
-
 -(int) findNextGoodAltIdx:(int)startIdx
 {
    int i = startIdx;
-   NSUInteger num = [points count];
+   NSUInteger num = [_points count];
    while (i < num)
    {
-      TrackPoint* pt = [points objectAtIndex:i];
+      TrackPoint* pt = [_points objectAtIndex:i];
        if ([pt validAltitude])
       {
          return i;
@@ -590,7 +527,6 @@
    return -1;
 }
 
-
 -(TrackPoint*) nextValidGoodDistancePoint:(int)start
 {
 	TrackPoint* pt = nil;
@@ -610,35 +546,30 @@
 	return pt;
 }
 
-
 - (float) movingSpeedThreshold
 {
    return [Utils floatFromDefaults:RCBDefaultMinSpeed];
 }
 
-
 - (float) movingDistanceThreshold
 {
    return [Utils floatFromDefaults:RCBDefaultMinDistance]/5280.0;
 }
-
-
-
 
 //-------------------------------------------------------------------------------------------------------------
 //---- LAP-RELATED METHODS ------------------------------------------------------------------------------------
 
 // NOTE: all track point indices stored in the lapInfo structure are from the
-// goodPoints array  (dead zone markers are excluded)
-
-- (int) findLapIndex:(Lap*)lap
-{
-    NSUInteger numLaps = [laps count];
+// goodPoints array  (dead zone _markers are excluded)
+
+- (int) findLapIndex:(Lap*)_lap
+{
+    NSUInteger numLaps = [_laps count];
 	int ret = -1;
 	int idx;
 	for (idx=0; idx<numLaps; idx++)
 	{
-		if (lap == [laps objectAtIndex:idx])
+		if (_lap == [_laps objectAtIndex:idx])
 		{
 			ret = idx;
 			break;
@@ -647,15 +578,14 @@
 	return ret;
 }
 
-
-- (NSArray*) lapPoints:(Lap*)lap
+- (NSArray*) lapPoints:(Lap*)_lap
 {
 	NSMutableArray* arr = nil;
-	LapInfo* li = [self getLapInfo:lap];
+	LapInfo* li = [self getLapInfo:_lap];
 	if (li != nil)
 	{
-		int sp = [li startingPointIndex];
-		int np = [li numPoints];
+		int sp = [li _startingPointIndex];
+		int np = [li _numPoints];
 		int i;
 		NSArray* pts = [self goodPoints];
 		arr = [NSMutableArray arrayWithCapacity:np];
@@ -675,32 +605,30 @@
 	return arr;
 }
 
-
-- (int) lapStartingIndex:(Lap*)lap
+- (int) lapStartingIndex:(Lap*)_lap
 {
 	int sp = 0;
-	LapInfo* li = [self getLapInfo:lap];
+	LapInfo* li = [self getLapInfo:_lap];
 	if (li != nil)
 	{
-		sp = [li startingPointIndex];
+		sp = [li _startingPointIndex];
 	}
 	return sp;
 }
 
-
 - (void) updateLapInfoArray
 {
 	[lapInfoArray removeAllObjects];
-    NSUInteger numLaps = [laps count];
+    NSUInteger numLaps = [_laps count];
 	int last = 0;
 	int i;
 	NSArray* pts = [self goodPoints];
     int count = (int)[pts count];
-	NSTimeInterval activeTimeDelta = 0.0;
+	NSTimeInterval _activeTimeDelta = 0.0;
 	for (i=0; i<numLaps; i++)
 	{
-		Lap* lap = [laps objectAtIndex:i];
-		float std = [lap startingWallClockTimeDelta];
+		Lap* _lap = [_laps objectAtIndex:i];
+		float std = [_lap startingWallClockTimeDelta];
 		int sp = [self findFirstGoodPointAtOrAfterDelta:std startAt:last];
 		int np = 0;
 		if (sp < 0)
@@ -712,7 +640,7 @@
 		{
 			if (i < (numLaps-1))
 			{
-				Lap* nextLap = [laps objectAtIndex:i+1];
+				Lap* nextLap = [_laps objectAtIndex:i+1];
 				float nstd = [nextLap startingWallClockTimeDelta];
 				int endi = [self findFirstGoodPointAtOrAfterDelta:nstd startAt:sp];
 				if (endi == -1) endi = count - 1;		// if fell off the end, set to last point
@@ -727,31 +655,29 @@
 		if (sp < 0) sp = 0;
 		last = sp + np - 1;
 		if (last < 0) last = 0;
-		LapInfo* li = [[LapInfo alloc] initWithData:lap startIdx:sp numPoints:np];
+		LapInfo* li = [[LapInfo alloc] initWithData:_lap startIdx:sp _numPoints:np];
 		[lapInfoArray addObject:li];
-		//printf("lap %d active time delta %0.1f\n", activeTimeDelta);
-		[li setActiveTimeDelta:activeTimeDelta];
-		activeTimeDelta += [self movingDurationOfLap:lap];
-	}
-}
-
+		//printf("_lap %d active time delta %0.1f\n", _activeTimeDelta);
+		[li setActiveTimeDelta:_activeTimeDelta];
+		_activeTimeDelta += [self movingDurationOfLap:_lap];
+	}
+}
 
 - (void) invalidateAllLapStats
 {
-    NSUInteger num = [laps count];
+    NSUInteger num = [_laps count];
 	int i;
 	for (i=0; i<num; i++)
 	{
-		Lap* lap = [laps objectAtIndex:i];
-		[lap setStatsCalculated:NO];
-	}
-}
-
-
-- (LapInfo*) getLapInfo:(Lap*)lap
+		Lap* _lap = [_laps objectAtIndex:i];
+		[_lap setStatsCalculated:NO];
+	}
+}
+
+- (LapInfo*) getLapInfo:(Lap*)_lap
 {
 	LapInfo* li = nil;
-	int idx = [self findLapIndex:lap];
+	int idx = [self findLapIndex:_lap];
 	if (idx >= 0)
 	{
 		li = [lapInfoArray objectAtIndex:idx];
@@ -759,54 +685,52 @@
 	return li;
 }
 
-
-- (NSTimeInterval) lapActiveTimeDelta:(Lap*)lap
+- (NSTimeInterval) lapActiveTimeDelta:(Lap*)_lap
 {
 	NSTimeInterval answer = 0.0;
-	LapInfo* li = [self getLapInfo:lap];
+	LapInfo* li = [self getLapInfo:_lap];
 	if (li != nil)
 	{
 #if 0
-		int sp = [li startingPointIndex];
-		if (lap && laps && (lap != [laps objectAtIndex:0]))	// starting lap is assumed to start at time 0
-			answer = [[goodPoints objectAtIndex:sp] activeTimeDelta];
+		int sp = [li _startingPointIndex];
+		if (_lap && _laps && (_lap != [_laps objectAtIndex:0]))	// starting _lap is assumed to start at time 0
+			answer = [[goodPoints objectAtIndex:sp] _activeTimeDelta];
 #endif
-		answer = [li activeTimeDelta];
+		answer = [li _activeTimeDelta];
 	}
 	return answer;
 }
 
-
-- (void) calculateLapStats:(Lap*)lap
-{
-	BOOL done = [lap statsCalculated];
+- (void) calculateLapStats:(Lap*)_lap
+{
+	BOOL done = [_lap statsCalculated];
 	if (!done)
 	{
-		[lap setStatsCalculated:YES];
-		LapInfo* li = [self getLapInfo:lap];
+		[_lap setStatsCalculated:YES];
+		LapInfo* li = [self getLapInfo:_lap];
 		if (li != nil)
 		{
-			int sp = [li startingPointIndex];
-			//printf("lap start:%d num:%d total:%d\n", sp, [li numPoints], [[self goodPoints] count]);
-			if ([li numPoints] > 1)
-			{
-				[self calculateStats:[lap getStatArray] startIdx:sp endIdx:(sp + [li numPoints] - 1)];
+			int sp = [li _startingPointIndex];
+			//printf("_lap start:%d num:%d total:%d\n", sp, [li _numPoints], [[self goodPoints] count]);
+			if ([li _numPoints] > 1)
+			{
+				[self calculateStats:[_lap getStatArray] startIdx:sp endIdx:(sp + [li _numPoints] - 1)];
 			}
 			else
 			{
-				// no points for lap, so just use lap data if it exists
-				struct tStatData* statData = [lap getStatArray];
-				float totalDistance = [lap distance];
+				// no _points for _lap, so just use _lap data if it exists
+				struct tStatData* statData = [_lap getStatArray];
+				float totalDistance = [_lap _distance];
 				statData[kST_Distance].vals[kVal] = totalDistance;
-				statData[kST_Heartrate].vals[kMax] = [lap maxHeartRate];
-				statData[kST_Heartrate].vals[kAvg] = [lap averageHeartRate];
-				statData[kST_Cadence].vals[kAvg] = [lap averageCadence];
-				//statData[kST_Power].vals[kAvg] = [lap averagePower];
-				statData[kST_Calories].vals[kVal] = [lap calories];
-				statData[kST_Durations].vals[kElapsed] = [lap totalTime];
-				statData[kST_Durations].vals[kMoving] = [lap deviceTotalTime];
-				statData[kST_Speed].vals[kMax] = statData[kST_MovingSpeed].vals[kMax] = [lap maxSpeed];
-				float dur = [lap deviceTotalTime];
+				statData[kST_Heartrate].vals[kMax] = [_lap maxHeartRate];
+				statData[kST_Heartrate].vals[kAvg] = [_lap averageHeartRate];
+				statData[kST_Cadence].vals[kAvg] = [_lap averageCadence];
+				//statData[kST_Power].vals[kAvg] = [_lap averagePower];
+				statData[kST_Calories].vals[kVal] = [_lap calories];
+				statData[kST_Durations].vals[kElapsed] = [_lap totalTime];
+				statData[kST_Durations].vals[kMoving] = [_lap deviceTotalTime];
+				statData[kST_Speed].vals[kMax] = statData[kST_MovingSpeed].vals[kMax] = [_lap maxSpeed];
+				float dur = [_lap deviceTotalTime];
 				if (dur > 0.0)
 				{
 					statData[kST_Speed].vals[kAvg] = statData[kST_MovingSpeed].vals[kAvg] = totalDistance/(60.0*60.0*dur);
@@ -816,24 +740,23 @@
 	}
 }
 
-- (float)statForLap:(Lap*)lap statType:(tStatType)stat index:(int)idx atActiveTimeDelta:(NSTimeInterval*)atTime 
-{
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:stat];
+- (float)statForLap:(Lap*)_lap statType:(tStatType)stat index:(int)idx atActiveTimeDelta:(NSTimeInterval*)atTime 
+{
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:stat];
 	if (atTime != nil) *atTime = data->atActiveTimeDelta[idx];
 	return data->vals[idx];
 }	
 
-
-- (float)maxCadenceForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
+- (float)maxCadenceForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
 {
 	float answer = 0.0;
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Cadence];
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Cadence];
 	if (t != nil) *t = data->atActiveTimeDelta[kMax];
 	if ([self usingDeviceLapData])
 	{
-		answer = (float)[lap maxCadence];
+		answer = (float)[_lap maxCadence];
 	}
 	else
 	{
@@ -842,58 +765,53 @@
 	return answer;
 }
 
-
-- (float)avgCadenceForLap:(Lap*)lap
+- (float)avgCadenceForLap:(Lap*)_lap
 {
 	float answer = 0.0;
-	if ([self usingDeviceLapData] && ([lap averageCadence] > 0))
-	{
-		answer = (float)[lap averageCadence];
+	if ([self usingDeviceLapData] && ([_lap averageCadence] > 0))
+	{
+		answer = (float)[_lap averageCadence];
 	}
 	else
 	{
-		[self calculateLapStats:lap];
-		struct tStatData* data = [lap getStat:kST_Cadence];
+		[self calculateLapStats:_lap];
+		struct tStatData* data = [_lap getStat:kST_Cadence];
 		answer = data->vals[kAvg];
 	}
 	return answer;
 }
 
-
-- (float)maxPowerForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
+- (float)maxPowerForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
 {
 	[self checkPowerData];
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Power];
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Power];
 	if (t != nil) *t = data->atActiveTimeDelta[kMax];
 	return data->vals[kMax];
 }
 
-
-- (float)avgPowerForLap:(Lap*)lap
+- (float)avgPowerForLap:(Lap*)_lap
 {
 	[self checkPowerData];
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Power];
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Power];
 	return data->vals[kAvg];
 }
 
-
-- (float)workForLap:(Lap*)lap
-{
-	return PowerDurationToWork([self avgPowerForLap:lap], 
-							   [self movingDurationOfLap:lap]);
-}
-
-
-- (float)maxHeartrateForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
+- (float)workForLap:(Lap*)_lap
+{
+	return PowerDurationToWork([self avgPowerForLap:_lap], 
+							   [self movingDurationOfLap:_lap]);
+}
+
+- (float)maxHeartrateForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
 {
 	float answer = 0.0;
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Heartrate];
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Heartrate];
 	if ([self usingDeviceLapData])
 	{
-		answer = (float)[lap maxHeartRate];
+		answer = (float)[_lap maxHeartRate];
 	}
 	if (![self usingDeviceLapData] || (answer <= 0.0))
 	{
@@ -903,149 +821,134 @@
 	return answer;
 }
 
-
-- (float)minHeartrateForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
-{
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Heartrate];
+- (float)minHeartrateForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
+{
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Heartrate];
 	if (t != nil) *t = data->atActiveTimeDelta[kMin];
 	return data->vals[kMin];
 }
 
-
-- (float)avgHeartrateForLap:(Lap*)lap
+- (float)avgHeartrateForLap:(Lap*)_lap
 {
 	float answer = 0.0;
 	if ([self usingDeviceLapData])
 	{
-		answer = (float)[lap averageHeartRate];
+		answer = (float)[_lap averageHeartRate];
 	}
 	else
 	{
-		[self calculateLapStats:lap];
-		struct tStatData* data = [lap getStat:kST_Heartrate];
+		[self calculateLapStats:_lap];
+		struct tStatData* data = [_lap getStat:kST_Heartrate];
 		answer = data->vals[kAvg];
 	}
 	return answer;
 }
 
-
-- (float)maxAltitudeForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
-{
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Altitude];
+- (float)maxAltitudeForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
+{
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Altitude];
 	if (t != nil) *t = data->atActiveTimeDelta[kMax];
 	return data->vals[kMax];
 }
 
-
-- (float)minAltitudeForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
-{
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Altitude];
+- (float)minAltitudeForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
+{
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Altitude];
 	if (t != nil) *t = data->atActiveTimeDelta[kMin];
 	return data->vals[kMin];
 }
 
-
-- (float)avgAltitudeForLap:(Lap*)lap
-{
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Altitude];
+- (float)avgAltitudeForLap:(Lap*)_lap
+{
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Altitude];
 	return data->vals[kAvg];
 }
 
-
-- (float)maxSpeedForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
+- (float)maxSpeedForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
 {
 	float answer = 0.0;
 	if ([self usingDeviceLapData])
 	{
-		answer = [lap maxSpeed];
+		answer = [_lap maxSpeed];
 	}
 	else
 	{
-		[self calculateLapStats:lap];
-		struct tStatData* data = [lap getStat:kST_Speed];
+		[self calculateLapStats:_lap];
+		struct tStatData* data = [_lap getStat:kST_Speed];
 		if (t != nil) *t = data->atActiveTimeDelta[kMax];
 		answer = data->vals[kMax];
 	}
 	return answer;
 }
 
-
-- (float)avgGradientForLap:(Lap*)lap
-{
-   [self calculateLapStats:lap];
-   struct tStatData* data = [lap getStat:kST_Gradient];
+- (float)avgGradientForLap:(Lap*)_lap
+{
+   [self calculateLapStats:_lap];
+   struct tStatData* data = [_lap getStat:kST_Gradient];
    return data->vals[kAvg];
 }
 
-
-- (float)maxGradientForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
-{
-   [self calculateLapStats:lap];
-   struct tStatData* data = [lap getStat:kST_Gradient];
+- (float)maxGradientForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
+{
+   [self calculateLapStats:_lap];
+   struct tStatData* data = [_lap getStat:kST_Gradient];
    if (t != nil) *t = data->atActiveTimeDelta[kMax];
    return data->vals[kMax];
 }
 
-
-- (float)minGradientForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
-{
-   [self calculateLapStats:lap];
-   struct tStatData* data = [lap getStat:kST_Gradient];
+- (float)minGradientForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
+{
+   [self calculateLapStats:_lap];
+   struct tStatData* data = [_lap getStat:kST_Gradient];
    if (t != nil) *t = data->atActiveTimeDelta[kMin];
    return data->vals[kMin];
 }
 
-
-- (float)avgTemperatureForLap:(Lap*)lap
-{
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Temperature];
+- (float)avgTemperatureForLap:(Lap*)_lap
+{
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Temperature];
 	return data->vals[kAvg];
 }
 
-
-- (float)maxTemperatureForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
-{
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Temperature];
+- (float)maxTemperatureForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
+{
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Temperature];
 	if (t != nil) *t = data->atActiveTimeDelta[kMax];
 	return data->vals[kMax];
 }
 
-
-- (float)minTemperatureForLap:(Lap*)lap atActiveTimeDelta:(NSTimeInterval*)t
-{
-	[self calculateLapStats:lap];
-	struct tStatData* data = [lap getStat:kST_Temperature];
+- (float)minTemperatureForLap:(Lap*)_lap atActiveTimeDelta:(NSTimeInterval*)t
+{
+	[self calculateLapStats:_lap];
+	struct tStatData* data = [_lap getStat:kST_Temperature];
 	if (t != nil) *t = data->atActiveTimeDelta[kMin];
 	return data->vals[kMin];
 }
 
-
--(NSDate*) lapStartTime:(Lap*)lap 
-{
-	return [[self creationTime] dateByAddingTimeInterval:[lap startingWallClockTimeDelta]];
-}
-
-
--(NSDate*) lapEndTime:(Lap*)lap 
-{
-	return [[self lapStartTime:lap] dateByAddingTimeInterval:[self durationOfLap:lap]];
-}
-
+-(NSDate*) lapStartTime:(Lap*)_lap 
+{
+	return [[self _creationTime] dateByAddingTimeInterval:[_lap startingWallClockTimeDelta]];
+}
+
+-(NSDate*) lapEndTime:(Lap*)_lap 
+{
+	return [[self lapStartTime:_lap] dateByAddingTimeInterval:[self durationOfLap:_lap]];
+}
 
 -(int)lapIndexOfPoint:(TrackPoint*)pt
 {
 	float ptTime = [pt wallClockDelta];
-    int numLaps = (int)[laps count];
+    int numLaps = (int)[_laps count];
 	for (int i=numLaps-1; i>=0; i--)
 	{
-		Lap* lap = [laps objectAtIndex:i];
-		if (ptTime >= [lap startingWallClockTimeDelta])
+		Lap* _lap = [_laps objectAtIndex:i];
+		if (ptTime >= [_lap startingWallClockTimeDelta])
 		{
 			return i;
 		}
@@ -1054,20 +957,20 @@
 }
 	
 
-- (float)realDurationOfLap:(Lap*)lap
+- (float)realDurationOfLap:(Lap*)_lap
 {
 	NSTimeInterval totalInterval = 0.0;
-	NSDate* startTime = [self lapStartTime:lap];
-	if (lap != nil)
+	NSDate* startTime = [self lapStartTime:_lap];
+	if (_lap != nil)
 	{
 		NSDate* leTime = nil;
-        NSUInteger numLaps = [laps count];
-		int idx = [self findLapIndex:lap];
+        NSUInteger numLaps = [_laps count];
+		int idx = [self findLapIndex:_lap];
 		if ((idx >= 0) && (idx < numLaps))
 		{
 			if (idx < (numLaps-1))
 			{
-				Lap* nextLap = [laps objectAtIndex:idx+1];
+				Lap* nextLap = [_laps objectAtIndex:idx+1];
 				leTime = [self lapStartTime:nextLap];
 			}
 			else
@@ -1077,12 +980,12 @@
 				if (numPts > 0)
 				{
 					//leTime = [[gpts objectAtIndex:(numPts-1)] date];
-					leTime = [[self creationTime] dateByAddingTimeInterval:[[gpts objectAtIndex:(numPts-1)] wallClockDelta]];
+					leTime = [[self _creationTime] dateByAddingTimeInterval:[[gpts objectAtIndex:(numPts-1)] wallClockDelta]];
 				}
 				else
 				{
-					// no points, just use lap values
-					leTime = [[lap origStartTime] dateByAddingTimeInterval:[lap totalTime]];
+					// no _points, just use _lap values
+					leTime = [[_lap origStartTime] dateByAddingTimeInterval:[_lap totalTime]];
 				}
 			}
 			if (leTime)
@@ -1093,64 +996,61 @@
 	return totalInterval;
 }
 
-
 					  
-- (float)durationOfLap:(Lap*)lap
-{
-	NSTimeInterval totalInterval = [self realDurationOfLap:lap];
+- (float)durationOfLap:(Lap*)_lap
+{
+	NSTimeInterval totalInterval = [self realDurationOfLap:_lap];
 	// wall clock duration MUST be >= moving duration!
-	float movingDur = [self movingDurationOfLap:lap];
+	float movingDur = [self movingDurationOfLap:_lap];
 	if (totalInterval < movingDur) totalInterval = movingDur;
 	if (totalInterval < 0.0) totalInterval = 0.0;
 	return totalInterval;
 }
 
-
-- (void)addLapInFront:(Lap*)lap
-{
-	if ([laps containsObject:lap] == NO)
-	{
-	   if ([laps count] > 0)
+- (void)addLapInFront:(Lap*)_lap
+{
+	if ([_laps containsObject:_lap] == NO)
+	{
+	   if ([_laps count] > 0)
 	   {
-		   NSTimeInterval std = [lap startingWallClockTimeDelta];
-		   Lap* firstLap = [laps objectAtIndex:0];
+		   NSTimeInterval std = [_lap startingWallClockTimeDelta];
+		   Lap* firstLap = [_laps objectAtIndex:0];
 		   if ([firstLap startingWallClockTimeDelta] == std)
 		   {
-			   [firstLap setStartingWallClockTimeDelta:std +[lap totalTime]];
+			   [firstLap setStartingWallClockTimeDelta:std +[_lap totalTime]];
 		   }
 	   }
-	   [laps addObject:lap];
-		[laps sortUsingSelector:@selector(compare:)];
-		//NSLog(@"added lap %d to %@, total: %d\n", [lap index], name, [laps count]);
+	   [_laps addObject:_lap];
+		[_laps sortUsingSelector:@selector(compare:)];
+		//NSLog(@"added _lap %d to %@, total: %d\n", [_lap index], _name, [_laps count]);
 	}
 	else
 	{
-		//NSLog(@"skipped lap %d %@ (already there), total: %d\n", [lap index], name, [laps count]);
+		//NSLog(@"skipped _lap %d %@ (already there), total: %d\n", [_lap index], _name, [_laps count]);
 	}
 	[self updateLapInfoArray];
 }
 
-
 - (Lap*)addLap:(NSTimeInterval)atActiveTimeDelta
 {
-	Lap* lap = nil;
+	Lap* _lap = nil;
 	int idx = [self findIndexOfFirstPointAtOrAfterActiveTimeDelta:atActiveTimeDelta];
 	if (idx > 0)
 	{ 
-		TrackPoint* firstPoint = [points objectAtIndex:idx];
+		TrackPoint* firstPoint = [_points objectAtIndex:idx];
 		NSTimeInterval lapStartWallClockDelta = [firstPoint wallClockDelta];
-        NSTimeInterval lapStartActiveTimeDelta = [firstPoint activeTimeDelta];
-		// laps can only be inserted 10 seconds after track start or 10 seconds before the end
+        NSTimeInterval lapStartActiveTimeDelta = [firstPoint _activeTimeDelta];
+		// _laps can only be inserted 10 seconds after track start or 10 seconds before the end
 		if (IS_BETWEEN(10.0, lapStartWallClockDelta, [self duration] - 10.0))
 		{
-			NSDate* startDate = [[self creationTime] dateByAddingTimeInterval:lapStartWallClockDelta];
+			NSDate* startDate = [[self _creationTime] dateByAddingTimeInterval:lapStartWallClockDelta];
 			
-			int numLaps = (int)[laps count];
+			int numLaps = (int)[_laps count];
 			int insertBeforeIndex = numLaps;
 			for (int i = 0; i<numLaps; i++)
 			{
-				Lap* lap = [laps objectAtIndex:i];
-				if ([lap startingWallClockTimeDelta] > lapStartWallClockDelta)
+				Lap* _lap = [_laps objectAtIndex:i];
+				if ([_lap startingWallClockTimeDelta] > lapStartWallClockDelta)
 				{
 					insertBeforeIndex = i;
 					break;
@@ -1162,14 +1062,14 @@
             float prevLapActiveTimeDelta = prevLap ? [self lapActiveTimeDelta:prevLap] : 0.0;
             if (insertBeforeIndex < numLaps)
 			{
-				nextLap = [laps objectAtIndex:insertBeforeIndex];
+				nextLap = [_laps objectAtIndex:insertBeforeIndex];
                 
 			}
 			if (insertBeforeIndex > 0)
 			{
-				prevLap = [laps objectAtIndex:insertBeforeIndex-1];
-			}
-			lap = [[Lap alloc] initWithGPSData:insertBeforeIndex
+				prevLap = [_laps objectAtIndex:insertBeforeIndex-1];
+			}
+			_lap = [[Lap alloc] initWithGPSData:insertBeforeIndex
 						startTimeSecsSince1970:(time_t)[startDate timeIntervalSince1970]
 									 totalTime:(nextLap ? [nextLap startingWallClockTimeDelta] - lapStartWallClockDelta : 0.0)*100
 								 totalDistance:0.0		// currently calculated
@@ -1185,78 +1085,77 @@
 									 intensity:prevLap ? [prevLap intensity] : 0
 									   trigger:prevLap ? [prevLap triggerMethod] : 0];
 			
-			[lap setStartingWallClockTimeDelta:lapStartWallClockDelta];
+			[_lap setStartingWallClockTimeDelta:lapStartWallClockDelta];
 			if (prevLap)
 			{
-				[prevLap setEndLatitude:[lap beginLatitude]];
-				[prevLap setEndLongitude:[lap beginLongitude]];
+				[prevLap setEndLatitude:[_lap beginLatitude]];
+				[prevLap setEndLongitude:[_lap beginLongitude]];
 				[prevLap setTotalTime:lapStartWallClockDelta - [prevLap startingWallClockTimeDelta]];
                 [prevLap setDeviceTotalTime:lapStartActiveTimeDelta - prevLapActiveTimeDelta];
 			}
             if (nextLap)
             {
-                [lap setTotalTime:[nextLap startingWallClockTimeDelta] - lapStartWallClockDelta];
-                [lap setDeviceTotalTime:nextLapActiveTimeDelta - lapStartActiveTimeDelta];
+                [_lap setTotalTime:[nextLap startingWallClockTimeDelta] - lapStartWallClockDelta];
+                [_lap setDeviceTotalTime:nextLapActiveTimeDelta - lapStartActiveTimeDelta];
             }
             else
             {
-                [lap setTotalTime:[self duration] - lapStartWallClockDelta];
-                [lap setDeviceTotalTime:[self movingDuration] - lapStartActiveTimeDelta];
+                [_lap setTotalTime:[self duration] - lapStartWallClockDelta];
+                [_lap setDeviceTotalTime:[self movingDuration] - lapStartActiveTimeDelta];
             }
 			for (int i = insertBeforeIndex; i<numLaps; i++)
 			{
-				[(Lap*)[laps objectAtIndex:i] setIndex:i+1];
-			}
-			[laps addObject:lap];
-			[laps sortUsingSelector:@selector(compare:)];
+				[(Lap*)[_laps objectAtIndex:i] setIndex:i+1];
+			}
+			[_laps addObject:_lap];
+			[_laps sortUsingSelector:@selector(compare:)];
 			[self setUseDeviceLapData:NO];	// this will cause issues with the 310xt
 			[self updateLapInfoArray];
 			[self invalidateAllLapStats];
 		}
 	}
-	return lap;
-}
-
-
-- (BOOL)deleteLap:(Lap*)lap
+	return _lap;
+}
+
+- (BOOL)deleteLap:(Lap*)_lap
 {
 	BOOL ret = NO;
-	if (([laps containsObject:lap] == YES) && ([laps count] > 1))
-	{
-		int numLaps = (int)[laps count];
-		int lapIndex = (int)[laps indexOfObject:lap];
+	if (([_laps containsObject:_lap] == YES) && ([_laps count] > 1))
+	{
+		int numLaps = (int)[_laps count];
+		int lapIndex = (int)[_laps indexOfObject:_lap];
 		Lap* prevLap = nil;
 		Lap* nextLap = nil;
 		if (lapIndex > 0)
 		{
-			prevLap = [laps objectAtIndex:lapIndex-1];
+			prevLap = [_laps objectAtIndex:lapIndex-1];
 		}
 		if (lapIndex < (numLaps-1))
 		{
-			nextLap = [laps objectAtIndex:lapIndex+1];
-		}
-		[laps removeObject:lap];
+			nextLap = [_laps objectAtIndex:lapIndex+1];
+		}
+		[_laps removeObject:_lap];
 		if (prevLap)
 		{
-			// previous lap is now extended to contain lap being deleted
-			[prevLap setEndLatitude:[lap endLatitude]];
-			[prevLap setEndLongitude:[lap endLongitude]];
-			[prevLap setTotalTime:[prevLap totalTime] + [lap totalTime]];
-			[prevLap setDeviceTotalTime:[prevLap deviceTotalTime] + [lap deviceTotalTime]];
-			[prevLap setCalories:[prevLap calories] + [lap calories]];
+			// previous _lap is now extended to contain _lap being deleted
+			[prevLap setEndLatitude:[_lap endLatitude]];
+			[prevLap setEndLongitude:[_lap endLongitude]];
+			[prevLap setTotalTime:[prevLap totalTime] + [_lap totalTime]];
+			[prevLap setDeviceTotalTime:[prevLap deviceTotalTime] + [_lap deviceTotalTime]];
+			[prevLap setCalories:[prevLap calories] + [_lap calories]];
 		}
 		else if (nextLap)
 		{
-			// no prev lap, but there is a next lap (deleting first lap)
-			[nextLap setBeginLatitude:[lap beginLatitude]];
-			[nextLap setBeginLongitude:[lap beginLongitude]];
-			[nextLap setTotalTime:[nextLap totalTime] + [lap totalTime]];
-			[nextLap setDeviceTotalTime:[nextLap deviceTotalTime] + [lap deviceTotalTime]];
-			[nextLap setCalories:[nextLap calories] + [lap calories]];
-			[nextLap setOrigStartTime:[lap origStartTime]];
+			// no prev _lap, but there is a next _lap (deleting first _lap)
+			[nextLap setBeginLatitude:[_lap beginLatitude]];
+			[nextLap setBeginLongitude:[_lap beginLongitude]];
+			[nextLap setTotalTime:[nextLap totalTime] + [_lap totalTime]];
+			[nextLap setDeviceTotalTime:[nextLap deviceTotalTime] + [_lap deviceTotalTime]];
+			[nextLap setCalories:[nextLap calories] + [_lap calories]];
+			[nextLap setOrigStartTime:[_lap origStartTime]];
 			// NOTE: this case MUST RESET STARTING WALL TIME DELTA!  Other cases simply
-			// extend the LENGTH of the previous lap instead.
-			[nextLap setStartingWallClockTimeDelta:[lap startingWallClockTimeDelta]];
+			// extend the LENGTH of the previous _lap instead.
+			[nextLap setStartingWallClockTimeDelta:[_lap startingWallClockTimeDelta]];
 		}
 		[self updateLapInfoArray];
 		[self invalidateAllLapStats];
@@ -1265,69 +1164,64 @@
 	return ret;
 }
 
-
-- (float)avgLapSpeed:(Lap*)lap
+- (float)avgLapSpeed:(Lap*)_lap
 {
 	float answer = 0.0;
-    if (lap != nil)
-	{
-		float totalDist = [self distanceOfLap:lap];
-		NSTimeInterval totalInterval = [self durationOfLap:lap];
+    if (_lap != nil)
+	{
+		float totalDist = [self distanceOfLap:_lap];
+		NSTimeInterval totalInterval = [self durationOfLap:_lap];
 		if (totalInterval > 0.0)
 		   answer = totalDist/(totalInterval/(60.0*60.0));
    }
    return answer;
 }
 
-
-- (float)lapClimb:(Lap*)lap
-{
-   [self calculateLapStats:lap];
-   struct tStatData* data = [lap getStat:kST_ClimbDescent];
+- (float)lapClimb:(Lap*)_lap
+{
+   [self calculateLapStats:_lap];
+   struct tStatData* data = [_lap getStat:kST_ClimbDescent];
    return data->vals[kMax];
 }
 
-
-- (float)lapDescent:(Lap*)lap
-{
-   [self calculateLapStats:lap];
-   struct tStatData* data = [lap getStat:kST_ClimbDescent];
+- (float)lapDescent:(Lap*)_lap
+{
+   [self calculateLapStats:_lap];
+   struct tStatData* data = [_lap getStat:kST_ClimbDescent];
    return data->vals[kMin];
 }
 
-
-- (float) caloriesForLap:(Lap*)lap
+- (float) caloriesForLap:(Lap*)_lap
 {
 	float answer = 0.0;
 	if ([self usingDeviceLapData])
 	{
-		answer = [lap calories];
+		answer = [_lap calories];
 	}
 	else
 	{
-		[self calculateLapStats:lap];
-		struct tStatData* data = [lap getStat:kST_Calories];
+		[self calculateLapStats:_lap];
+		struct tStatData* data = [_lap getStat:kST_Calories];
 		answer = data->vals[kVal];
 	}
 	return answer;
 }
 
-
 - (BOOL) isTimeOfDayInLap:(Lap*)l tod:(NSDate*)tod
 {
-    NSUInteger num = [laps count];
+    NSUInteger num = [_laps count];
    int i;
    NSDate* endTime = [NSDate distantFuture];
   // NSDate* startTime = [l startTime];
    NSDate* startTime = [self lapStartTime:l];
    for (i=0; i<num; i++)
    {
-      if ([laps objectAtIndex:i] == l)
+      if ([_laps objectAtIndex:i] == l)
       {
          if (i < (num-1))
          {
-            //endTime = [[laps objectAtIndex:i+1] startTime];
-			 endTime = [self lapStartTime:[laps objectAtIndex:i+1]];
+            //endTime = [[_laps objectAtIndex:i+1] startTime];
+			 endTime = [self lapStartTime:[_laps objectAtIndex:i+1]];
          }
          break;
       }
@@ -1338,7 +1232,6 @@
    
 }
 
-
 - (float)interpolateDistance:(int)pt1idx secsFromStart:(float)secsFromTrackStart
 {
 	float d = 0.0;
@@ -1354,9 +1247,9 @@
 			--pt1idx;
 			pt1 = [pts objectAtIndex:pt1idx];
 		}
-		float d1 = [pt1 distance];
+		float d1 = [pt1 _distance];
 		d = d1;
-		// now find the next point with a valid distance
+		// now find the next point with a valid _distance
 		TrackPoint* pt2 = [self nextValidGoodDistancePoint:pt1idx];
 		if (pt2 != nil)
 		{
@@ -1364,8 +1257,8 @@
 			NSTimeInterval dt = [pt2 wallClockDelta] - [pt1 wallClockDelta]; 
 			if (dt > 0.0)
 			{
-				float d2 = [pt2 distance];
-				//NSTimeInterval pt1Secs = [[pt1 date] timeIntervalSinceDate:[self creationTime]];
+				float d2 = [pt2 _distance];
+				//NSTimeInterval pt1Secs = [[pt1 date] timeIntervalSinceDate:[self _creationTime]];
 				NSTimeInterval pt1Secs = [pt1 wallClockDelta];
 				// pt1 time should be less than target time
 				float dtp1 = secsFromTrackStart - pt1Secs;
@@ -1376,21 +1269,20 @@
 	return d;
 }
 
-
-- (float)distanceOfLap:(Lap*)lap
+- (float)distanceOfLap:(Lap*)_lap
 {
 	float answer = 0.0;
 	if ([self usingDeviceLapData])
 	{
-		answer = [lap distance];			
+		answer = [_lap _distance];			
 	}
 	else
 	{
-		LapInfo* li = [self getLapInfo:lap];
+		LapInfo* li = [self getLapInfo:_lap];
 		if (li != nil)
 		{
-			int sp = [li startingPointIndex];
-			int np = [li numPoints];
+			int sp = [li _startingPointIndex];
+			int np = [li _numPoints];
 			NSArray* pts = [self goodPoints];
 			int totalPts = (int)[pts count];
 			if (np > 1)
@@ -1400,8 +1292,8 @@
 				if (firstOfNextLap >= totalPts) firstOfNextLap = totalPts-1;
 				int atIdx;
 				float sd = [self lastValidDistanceUsingGoodPoints:sp atIdx:&atIdx];
-				//NSTimeInterval lapStartSecs = [[lap startTime] timeIntervalSinceDate:[self creationTime]];
-				NSTimeInterval lapStartSecs = [lap startingWallClockTimeDelta];
+				//NSTimeInterval lapStartSecs = [[_lap startTime] timeIntervalSinceDate:[self _creationTime]];
+				NSTimeInterval lapStartSecs = [_lap startingWallClockTimeDelta];
 				if (atIdx != -1)
 				{
 					sd = [self interpolateDistance:atIdx secsFromStart:lapStartSecs];      
@@ -1409,41 +1301,36 @@
 				float ed = [self lastValidDistanceUsingGoodPoints:firstOfNextLap atIdx:&atIdx];
 				if (atIdx != -1)
 				{
-					ed = [self interpolateDistance:atIdx secsFromStart:(lapStartSecs + [self durationOfLap:lap])];      
+					ed = [self interpolateDistance:atIdx secsFromStart:(lapStartSecs + [self durationOfLap:_lap])];      
 				}            
 				answer = ed - sd;
 			}
 			else
 			{
-				answer = [lap distance];			// no points, use lap data
+				answer = [_lap _distance];			// no _points, use _lap data
 			}
 		}
 	}
 	return answer;
 }
 
-
-- (NSString *)movingDurationForLapAsString:(Lap*)lap
-{
-	NSTimeInterval dur = [self movingDurationOfLap:lap];
+- (NSString *)movingDurationForLapAsString:(Lap*)_lap
+{
+	NSTimeInterval dur = [self movingDurationOfLap:_lap];
 	int hours = (int)dur/3600;
 	int mins = (int)(dur/60.0) % 60;
 	int secs = (int)dur % 60;
 	return [NSString stringWithFormat:@"%02d:%02d:%02d",hours, mins, secs];
 }
 
-
-
-- (NSString *)durationOfLapAsString:(Lap*)lap
-{
-	NSTimeInterval dur = [self durationOfLap:lap];
+- (NSString *)durationOfLapAsString:(Lap*)_lap
+{
+	NSTimeInterval dur = [self durationOfLap:_lap];
 	int hours = (int)dur/3600;
 	int mins = (int)(dur/60.0) % 60;
 	int secs = (int)dur % 60;
 	return [NSString stringWithFormat:@"%02d:%02d:%02d",hours, mins, secs];
 }
-
-
 
 //--------------------------------------------------------------------------------------
 //---- FIXUP TRACK METHODS -------------------------------------------------------------
@@ -1461,7 +1348,6 @@
    kStayOutOfDeadZone
 };
 
-
 BOOL allTheSame(BOOL* arr, int num, BOOL v)
 {
    int i;
@@ -1477,7 +1363,6 @@
       if (arr[i] == v) return YES;
    return NO;
 }
-
 
 // state during fixup
 static float			sSpeedThresh            = 0.0;
@@ -1493,7 +1378,6 @@
 static TrackPoint*		sLastGPSPoint           = nil;
 static int				sLastGoodAltIdx         = 0;
 
-
 - (BOOL) checkDeadZones:(NSArray*)pts start:(int)s state:(BOOL)idz deltaTime:(float)deltaTime
 {
     if ([self hasExplicitDeadZones]) return NO;
@@ -1526,14 +1410,13 @@
 	return (state == kEnterDeadZone) || (state == kStayInDeadZone);
 }
 
-
 -(void) smoothAltitudes:(NSArray*)pts
 {
 	int count = (int)[pts count];
 	float smoothingFactor = 0.0;
-	if (IS_BETWEEN(1.0, altitudeSmoothingFactor, 100.0))
-	{
-		smoothingFactor = altitudeSmoothingFactor;
+	if (IS_BETWEEN(1.0, _altitudeSmoothingFactor, 100.0))
+	{
+		smoothingFactor = _altitudeSmoothingFactor;
 	}
 	else
 	{
@@ -1564,7 +1447,6 @@
 	}
 }
 
-
 -(void)initLastGoodAltitude:(NSArray*)pts
 {
 	// set statics to first good altitude found, which may
@@ -1579,7 +1461,6 @@
 		sLastGoodAltIdx = nextGoodAltIdx;
 	}
 }
-
 
 -(void) checkAltitudes:(NSArray*)pts start:(int)sidx
 {
@@ -1619,7 +1500,6 @@
 	kLastPointExitedDeadZone
 };
 
-
 // updates sDeltaTime, sTimeToIgnore,  sNumMarkedDeadZones
 // sDeltaTime should be set to 0.0 if the time interval for the point is
 // being added to the "ignore" time
@@ -1628,7 +1508,7 @@
 	int ret = kNotInMarkedDeadZone;
 #if DEBUG_DEADZONES
 	NSDate* dt = [[NSDate alloc] initWithTimeInterval:[pt wallClockDelta]
-											sinceDate:creationTime];
+											sinceDate:_creationTime];
 #endif   
 	
 	switch (cdzState)
@@ -1675,7 +1555,6 @@
 #endif
 	return ret;
 }
-
 
 - (void) checkFirstAltitude:(NSArray*)pts idx:(int)cidx
 {
@@ -1694,12 +1573,11 @@
    }
 }
 
-
 - (float) findDeltaDistance:(TrackPoint*)pt lastDistance:(float)ld distToIgnore:(float)distToIgnore
 {
 	float deltaDist = 0.0;
-	float tentativeDistSoFar = [pt distance] - distToIgnore;
-	// if distance is unreasonable, don't use it.
+	float tentativeDistSoFar = [pt _distance] - distToIgnore;
+	// if _distance is unreasonable, don't use it.
 	if ((tentativeDistSoFar < 0) || (tentativeDistSoFar > 8000.0) || (tentativeDistSoFar < ld))
 	{
 		tentativeDistSoFar = ld; 
@@ -1743,7 +1621,6 @@
 	return spike;
 }
 
-
 -(float) filterFactor:(float)spd
 {
 	if (spd > 30.0) return 1.20;
@@ -1752,7 +1629,6 @@
 	else return 2.2;
 }
 
-
 - (BOOL) needsFilter:(float)spd lastSpeed:(float)lgs
 {
 	float ff = [self filterFactor:spd];
@@ -1760,17 +1636,16 @@
 		   ((lgs >  0.0) && (spd > (lgs * ff)));
 }
 
-
 #define BAD_SPEED       -42.0
 
 - (float) nextGoodSpeed:(int)sidx
 {
 	float ptSpd  = BAD_SPEED;
-	int ct = (int)[points count];
+	int ct = (int)[_points count];
 	int i = sidx;
 	while (i < ct)
 	{
-		TrackPoint* pt = [points objectAtIndex:i];
+		TrackPoint* pt = [_points objectAtIndex:i];
 		if (![pt isDeadZoneMarker])
 		{
 			ptSpd = [pt speed];
@@ -1851,11 +1726,10 @@
    return pt;
 }
 
-
 - (BOOL) fixDistance
 {
 	NSArray* gpts = [self goodPoints];
-	//NSArray* gpts = [self points];
+	//NSArray* gpts = [self _points];
 	TrackPoint*   lastRealGPSPoint           = nil;
 	TrackPoint*   nextRealGPSPoint           = nil;
 	TrackPoint*   lastPointWithGPS           = nil;
@@ -1902,7 +1776,7 @@
 															lat2:[nextRealGPSPoint latitude]
 															lon2:[nextRealGPSPoint longitude]];
 						float factor = (t1/deltaGPSTime);
-						deltaDist = (d * factor)-([lastPointWithGPS distance] - [lastRealGPSPoint distance]);     // sheesh
+						deltaDist = (d * factor)-([lastPointWithGPS _distance] - [lastRealGPSPoint _distance]);     // sheesh
 						lat = [lastRealGPSPoint latitude ] + (factor * ([nextRealGPSPoint latitude ] - [lastRealGPSPoint latitude ]));
 						lon = [lastRealGPSPoint longitude] + (factor * ([nextRealGPSPoint longitude] - [lastRealGPSPoint longitude]));
 						//printf("adjusting point: last:[%0.5f,%0.5f] next:[%0.5f,%0.5f] this:[%0.5f,%0.5f] factor:%0.2f  dist:%0.2f  dd:%0.2f\n",
@@ -1927,14 +1801,13 @@
 	return hasLatLon; 
 }
 
-
 -(void) copyOrigDistance
 {
 	float distSoFar = 0.0;
-    NSUInteger num = [points count];
+    NSUInteger num = [_points count];
 	for (int i=0; i<num; i++)
 	{
-		TrackPoint* pt = [points objectAtIndex:i];
+		TrackPoint* pt = [_points objectAtIndex:i];
 		float origDistance = [pt origDistance];
 		if (origDistance == BAD_DISTANCE)
 		{
@@ -1951,14 +1824,10 @@
 	}
 }
 
-
 -(BOOL) hasDistance
 {
 	return self.hasDistanceData;
 }
-
-
-
 
 -(void) setDistanceAndSpeed:(BOOL)doFiltering
 {
@@ -1967,24 +1836,24 @@
 	TrackPoint* lastPoint= nil;
 	float lastDistance = 0.0;
 	float lastGoodSpeed = 0.0;
-	NSMutableArray* pts = [self points];
+	NSMutableArray* pts = [self _points];
 	int num = (int)[pts count];
 	int lapIndex = 0;
-	int numLaps = (int)[laps count];
-	NSTimeInterval nextLapWallTimeStart = (laps && (numLaps > 0)) ? [[laps objectAtIndex:0] startingWallClockTimeDelta] : 0.0;
+	int numLaps = (int)[_laps count];
+	NSTimeInterval nextLapWallTimeStart = (_laps && (numLaps > 0)) ? [[_laps objectAtIndex:0] startingWallClockTimeDelta] : 0.0;
 	for (int i=0; i<num; i++)
 	{
 		TrackPoint* pt = [pts objectAtIndex:i];	
-		// find the first point in the lap; it's used below to filter out bad readings from the 705 at lap markers 
-		// (it always reports speed as zero at the point right at the lap marker).
-		if (([pt wallClockDelta] >=  nextLapWallTimeStart) && laps && (numLaps > lapIndex))
+		// find the first point in the _lap; it's used below to filter out bad readings from the 705 at _lap _markers 
+		// (it always reports speed as zero at the point right at the _lap marker).
+		if (([pt wallClockDelta] >=  nextLapWallTimeStart) && _laps && (numLaps > lapIndex))
 		{
 			[pt setIsFirstPointInLap:YES];
 			++lapIndex;
 			if (lapIndex < numLaps)
 			{
-				Lap* lap = [laps objectAtIndex:lapIndex];
-				nextLapWallTimeStart = [lap startingWallClockTimeDelta];
+				Lap* _lap = [_laps objectAtIndex:lapIndex];
+				nextLapWallTimeStart = [_lap startingWallClockTimeDelta];
 			}
 		}
 		else
@@ -2031,7 +1900,7 @@
 		{
 			[pt setDistance:lastDistance];
 		}
-		//printf("set pt distance, speed to %0.3f, %0.1f, OVERRIDE:%s, ignoring:%0.1f, delta:%0.1f\n", 
+		//printf("set pt _distance, speed to %0.3f, %0.1f, OVERRIDE:%s, ignoring:%0.1f, delta:%0.1f\n", 
 		//	   lastDistance, speed, [pt speedOverridden] ? "YES" : "NO", distToIgnore, deltaDist);
 		lastPoint = pt;
 	}
@@ -2044,8 +1913,8 @@
 	BOOL hasDevicePower = NO;
 	BOOL hasCadence = NO;
 	BOOL hasLocationData = NO;
-	CLEAR_FLAG(flags, kPowerDataCalculatedOrZeroed);
-	NSMutableArray* pts = [self points];
+	CLEAR_FLAG(_flags, kPowerDataCalculatedOrZeroed);
+	NSMutableArray* pts = [self _points];
 	int num = (int)[pts count];
 	if (num > 0)
 	{
@@ -2087,20 +1956,20 @@
 			hasDistance = self.hasDistanceData = (d != BAD_DISTANCE) && (d > 0.05);
 		}
 		
-		// this isn't great, but I can't see a clear way to do this without looping through all points here 
+		// this isn't great, but I can't see a clear way to do this without looping through all _points here 
 		// and then we loop through them again, below, while calculating active time.  ugh.
-		// the problem is the current speed filtering scheme needs to look at speeds for later points, so
+		// the problem is the current speed filtering scheme needs to look at speeds for later _points, so
 		// the raw speeds need to be calculated first in their entirety; *then* the filtering can be done in the loop below.
 		
 		[self setDistanceAndSpeed:NO];		// +10/22/07
-		if ([gpts count] > 0) firstDistance = lastDistance = [[gpts objectAtIndex:0] distance];       // track may start at non-zero distance
+		if ([gpts count] > 0) firstDistance = lastDistance = [[gpts objectAtIndex:0] _distance];       // track may start at non-zero _distance
 		
 		//---- now smooth altitudes, if the pref to do so is enabled
 		[self smoothAltitudes:pts];
 
 		TrackPoint* pt = [pts objectAtIndex:0];
 		TrackPoint* lastPoint = nil;
-		NSDate*  startTime = [[self creationTime] dateByAddingTimeInterval:[pt wallClockDelta]];
+		NSDate*  startTime = [[self _creationTime] dateByAddingTimeInterval:[pt wallClockDelta]];
 		NSDate* lastActiveTime = startTime;
 		NSTimeInterval mostRecentDelta = 0.0;
 		int markedDZState = kNotInMarkedDeadZone;
@@ -2129,7 +1998,7 @@
 							   start:i];
 
 				
-				//---- find delta distance, maybe update delta time as well if using GPS delta dist
+				//---- find delta _distance, maybe update delta time as well if using GPS delta dist
 				if ([pt validLatLon]) 
 				{
 					sLastGPSPoint = pt;
@@ -2138,7 +2007,6 @@
 				deltaDist = [self findDeltaDistance:pt 
 									   lastDistance:lastDistance 
 									   distToIgnore:sDistToIgnore];
-
 
 				if ((lastPoint != nil) && 
 					![lastPoint isDeadZoneMarker] &&
@@ -2172,8 +2040,8 @@
 
 #if DEBUG_DEADZONES
 					NSDate* ddt = [[NSDate alloc] initWithTimeInterval:[pt wallClockDelta]
-															 sinceDate:creationTime];
-					NSLog(@"%@ %0.1f delta dist:%9.6f delta time:%5.3f speed: %6.3f lastGoodSpeed:%0.1f %d dz:%s", ddt, [pt activeTimeDelta],  deltaDist, odt, speed, lastGoodSpeed, sNumDeadZones+1, inDeadZone ? "YES ************" : "NO");
+															 sinceDate:_creationTime];
+					NSLog(@"%@ %0.1f delta dist:%9.6f delta time:%5.3f speed: %6.3f lastGoodSpeed:%0.1f %d dz:%s", ddt, [pt _activeTimeDelta],  deltaDist, odt, speed, lastGoodSpeed, sNumDeadZones+1, inDeadZone ? "YES ************" : "NO");
 					[ddt autorelease];
 #endif
 				}
@@ -2218,42 +2086,39 @@
 	[self setHasDevicePower:hasDevicePower];
 	[self setHasCadence:hasCadence];
 	[self fixLapDurations];	// work around for 310XT-related changes
-	if (hasLocationData) SET_FLAG(flags, kHasLocationData);
-}
-
+	if (hasLocationData) SET_FLAG(_flags, kHasLocationData);
+}
 
 -(void)fixLapDurations
 {
-	BOOL hasDeviceTime = FLAG_IS_SET(flags, kHasDeviceTime);
-	for (Lap* lap in laps)
-	{
-		float wallTotalTime = [lap totalTime];
-		float deviceTime = [lap deviceTotalTime];
+	BOOL hasDeviceTime = FLAG_IS_SET(_flags, kHasDeviceTime);
+	for (Lap* _lap in _laps)
+	{
+		float wallTotalTime = [_lap totalTime];
+		float deviceTime = [_lap deviceTotalTime];
 		if (!hasDeviceTime && deviceTime == 0 && wallTotalTime != 0)
 		{
-			[lap setDeviceTotalTime:wallTotalTime];
-			SET_FLAG(flags, kHasDeviceTime);
-		}
-	}
-}
-
+			[_lap setDeviceTotalTime:wallTotalTime];
+			SET_FLAG(_flags, kHasDeviceTime);
+		}
+	}
+}
 
 -(void) doFixupAndCalcGradients
 {
 	[self fixupTrack];
 }
 
-
 - (int) findFirstPointAtOrAfterDelta:(NSTimeInterval)delta startAt:(int)idx
 {
-	int num = (int)[points count];
+	int num = (int)[_points count];
 	int i;
 	if (idx < 0) idx = 0;
 	if (idx < num)
 	{
 		for (i=idx; i<num; i++)
 		{
-			TrackPoint* pt = [points objectAtIndex:i];
+			TrackPoint* pt = [_points objectAtIndex:i];
 			//if ([[pt date] compare:time] != NSOrderedAscending)
 			if ([pt wallClockDelta] >= delta)
 			{
@@ -2263,7 +2128,6 @@
 	}
 	return -1;
 }
-
 
 - (int) findFirstGoodPointAtOrAfterDelta:(NSTimeInterval)delta startAt:(int)idx
 {
@@ -2296,7 +2160,7 @@
 		for (i=idx; i<num; i++)
 		{
 			TrackPoint* pt = [pts objectAtIndex:i];
-			if ([pt activeTimeDelta] >= delta)
+			if ([pt _activeTimeDelta] >= delta)
 			{
 				return i;
 			}
@@ -2305,21 +2169,19 @@
 	return -1;
 }
 
-
 - (int) findIndexOfFirstPointAtOrAfterActiveTimeDelta:(NSTimeInterval)atd
 {
-	int num = (int)[points count];
+	int num = (int)[_points count];
 	for (int i=0; i<num; i++)
 	{
-		TrackPoint* pt = [points objectAtIndex:i];
-		if ([pt activeTimeDelta] >= atd)
+		TrackPoint* pt = [_points objectAtIndex:i];
+		if ([pt _activeTimeDelta] >= atd)
 		{
 			return i;
 		}
 	}
 	return -1;
 }
-
 
 - (int)findIndexOfFirstPointAtOrAfterDistanceUsingGoodPoints:(float)dist startAt:(int)startIdx
 {
@@ -2328,7 +2190,7 @@
 	for (int i=startIdx; i<num; i++)
 	{
 		TrackPoint* pt = [pts objectAtIndex:i];
-		if ([pt distance] >= dist)
+		if ([pt _distance] >= dist)
 		{
 			return i;
 		}
@@ -2341,84 +2203,61 @@
 	return statsArray;
 }
 
-
 - (BOOL) isEqual:(id) t
 {
-   return ([[self creationTime] isEqualToDate:[t creationTime]]);
+   return ([[self _creationTime] isEqualToDate:[t _creationTime]]);
 }
 
 - (NSComparisonResult) comparator:(Track*) t
 {
-	return [[self creationTime] compare:[t creationTime]];
-}
-
-
-- (NSDate *)creationTime
-{
-	if (FLAG_IS_SET(flags, kOverrideCreationTime))
-	{
-		return creationTimeOverride;
+	return [[self _creationTime] compare:[t _creationTime]];
+}
+
+- (NSDate *)_creationTime
+{
+	if (FLAG_IS_SET(_flags, kOverrideCreationTime))
+	{
+		return _creationTimeOverride;
 	}
 	else
 	{
-		return creationTime;
-	}
-}
-
-- (void)setCreationTime:(NSDate *)d
-{
-   d = [d copy];
-   creationTime = d;
-}
-
-
-- (NSDate *)creationTimeOverride
-{
-	return creationTimeOverride;
-}
-
+		return _creationTime;
+	}
+}
+
+- (NSDate *)_creationTimeOverride
+{
+	return _creationTimeOverride;
+}
 
 - (void)setCreationTimeOverride:(NSDate *)d
 {
 	d = [d copy];
-	creationTimeOverride = d;
+	_creationTimeOverride = d;
 	if (d)
 	{
-		SET_FLAG(flags, kOverrideCreationTime);
+		SET_FLAG(_flags, kOverrideCreationTime);
 	}
 	else
 	{
-		CLEAR_FLAG(flags, kOverrideCreationTime);
-	}
-}
-
+		CLEAR_FLAG(_flags, kOverrideCreationTime);
+	}
+}
 
 - (void)clearCreationTimeOverride
 {
-	CLEAR_FLAG(flags, kOverrideCreationTime);
-	creationTimeOverride = nil;
-}
-
-
-
-
-- (int)secondsFromGMT 
-{
-   return secondsFromGMT;
-}
-
-- (void)setSecondsFromGMT:(int)value 
-{
-   if (secondsFromGMT != value) {
-      secondsFromGMT = value;
-   }
-}
-
-
+	CLEAR_FLAG(_flags, kOverrideCreationTime);
+	_creationTimeOverride = nil;
+}
+
+- (int)_secondsFromGMT 
+{
+   return _secondsFromGMT;
+}
 
 - (NSComparisonResult) compareByDate:(Track*)anotherTrack
 {
-   return [[self creationTime] compare:[anotherTrack creationTime]];
+   return [[self _creationTime] compare:[anotherTrack _creationTime]];
 }
 
 - (NSComparisonResult) compareByMovingDuration:(Track*)anotherTrack
@@ -2433,75 +2272,46 @@
 		return NSOrderedSame;
 }
 
-
-
-- (NSString *)name
-{
-   return name;
+- (NSString *)_name
+{
+   return _name;
    
 }
 
-- (void)setName:(NSString *)n
-{
-   n = [n copy];
-   name = n;
-}
-
-- (void) setAttributes:(NSMutableArray*)arr
-{
-	if (attributes != arr)
-	{
-		attributes = arr;
-	}
-    [attributes retain];    
-}
-
-
-- (int)flags
-{
-    return flags;
-}
-
+- (int)_flags
+{
+    return _flags;
+}
 
 - (void)setFlags:(int)f
 {
-    flags = f;
-}
-
-
-- (NSMutableArray*) attributes
-{
-   return attributes;
-}
-
-
-
-- (void)setDistance:(float)d
-{
-	distance = d;
-}
-
+    _flags = f;
+}
+
+- (NSMutableArray*) _attributes
+{
+   return _attributes;
+}
 
 - (void) setAttribute:(int)attr usingString:(NSString*)s
 {
-    // in case number of attributes has increased...
-    while ([attributes count] < kNumAttributes) {
-        [attributes addObject:@""];
+    // in case number of _attributes has increased...
+    while ([_attributes count] < kNumAttributes) {
+        [_attributes addObject:@""];
     }
         
-	if ((attr < [attributes count]) && (s != nil))
-	{
-		[attributes replaceObjectAtIndex:attr withObject:[s copy]];
+	if ((attr < [_attributes count]) && (s != nil))
+	{
+		[_attributes replaceObjectAtIndex:attr withObject:[s copy]];
 	   [[NSNotificationCenter defaultCenter] postNotificationName:@"InvalidateBrowserCache" object:nil];
 	}
 }
 
-
 - (NSString*) attribute:(int)attr
 {
-   if (attr < [attributes count])
+   if (attr < [_attributes count])
    {
-      return [attributes objectAtIndex:attr];
+      return [_attributes objectAtIndex:attr];
    }
    else
    {
@@ -2509,28 +2319,25 @@
    }
 }
 
-
-- (NSMutableArray*)points
-{
-   return points;
-}
-
-
+- (NSMutableArray*)_points
+{
+   return _points;
+}
 
 -(void) setPointsAndAdjustTimeDistance:(NSMutableArray*)pts newStartTime:(NSDate*)nst distanceOffset:(float)distOffset
 {
 	
-	NSTimeInterval timeDelta = [nst timeIntervalSinceDate:[self creationTime]];	// positive delta if starting LATER
+	NSTimeInterval timeDelta = [nst timeIntervalSinceDate:[self _creationTime]];	// positive delta if starting LATER
 	NSMutableArray* pointsToUpdate;
 	if (timeDelta >= 0.0)
 	{
-		pointsToUpdate = points;		// removing points from beginning, update time/distance of EXISTING points
-										// new points ('pts') are assumed to be a SUBSET of the existing set
+		pointsToUpdate = _points;		// removing _points from beginning, update time/_distance of EXISTING _points
+										// new _points ('pts') are assumed to be a SUBSET of the existing set
 	}
 	else
 	{
-		pointsToUpdate = pts;			// adding points to be beginning, adjust time/distance of all NEW points
-										// new points ('pts') are assumed to be a SUPERSET of the existing set
+		pointsToUpdate = pts;			// adding _points to be beginning, adjust time/_distance of all NEW _points
+										// new _points ('pts') are assumed to be a SUPERSET of the existing set
 	}
 	int count = (int)[pointsToUpdate count];
 	if (count > 0)
@@ -2544,11 +2351,11 @@
 				TrackPoint* pt = [pointsToUpdate objectAtIndex:i];
 				NSTimeInterval d = [pt wallClockDelta];
 				[pt setWallClockDelta:(d-timeDelta)];
-				d = [pt activeTimeDelta];
+				d = [pt _activeTimeDelta];
 				[pt setActiveTimeDelta:(d-timeDelta)];
 				if ([pt validDistance])
 				{
-					[pt setDistance:[pt distance] - distOffset];
+					[pt setDistance:[pt _distance] - distOffset];
 				}
 				if ([pt validOrigDistance])
 				{
@@ -2556,23 +2363,23 @@
 				}
 			}
 			[self invalidateStats];
-			if (laps)
-			{
-				count = (int)[laps count];
+			if (_laps)
+			{
+				count = (int)[_laps count];
 				for (int i=0; i<count; i++)
 				{
-					Lap* lap = [laps objectAtIndex:i];
-					[lap setStartingWallClockTimeDelta:[lap startingWallClockTimeDelta] - timeDelta];
+					Lap* _lap = [_laps objectAtIndex:i];
+					[_lap setStartingWallClockTimeDelta:[_lap startingWallClockTimeDelta] - timeDelta];
 				}
 				[self updateLapInfoArray];
 			}
-			if (markers && distOffset != 0.0)
-			{
-				count = (int)[markers count];
+			if (_markers && distOffset != 0.0)
+			{
+				count = (int)[_markers count];
 				for (int i=0; i<count; i++)
 				{
-					PathMarker* mrkr = [markers objectAtIndex:i];
-					float newd = [mrkr distance] - distOffset;
+					PathMarker* mrkr = [_markers objectAtIndex:i];
+					float newd = [mrkr _distance] - distOffset;
 					[mrkr setDistance:newd];
 				}
 			}
@@ -2581,7 +2388,6 @@
 	}
 	[self setPoints:pts];
 }
-
 
 - (void)setPoints:(NSMutableArray*)p
 {
@@ -2591,9 +2397,9 @@
     }
     else
     {
-        if (points != p)
+        if (_points != p)
         {
-            points = [p retain];
+            _points = [p retain];
         }
     }
 	[goodPoints removeAllObjects];      // force re-retrieval
@@ -2601,39 +2407,25 @@
 	[self invalidateAllLapStats];
 }
 
-
-- (NSMutableArray*)laps
-{
-   return laps;
-}
-
+- (NSMutableArray*)_laps
+{
+   return _laps;
+}
 
 - (void)setLaps:(NSMutableArray*)l
 {
-	if (l != laps)
-	{
-		laps = [l retain];
+	if (l != _laps)
+	{
+		_laps = [l retain];
 	}
 	[self updateLapInfoArray];
 	[self invalidateAllLapStats];
 }
 
-
-- (NSMutableArray*)markers
-{
-   return markers;
-}
-
-
-- (void)setMarkers:(NSMutableArray*)ms
-{
-	if (ms != markers)
-	{
-		markers = [ms retain];
-	}
-    //NSLog(@"track:setMarkers %x %d", markers, [markers retainCount]);
-}
-
+- (NSMutableArray*)_markers
+{
+   return _markers;
+}
 
 - (float)lastValidDistanceUsingGoodPoints:(int)startIdx atIdx:(int*)atIdxPtr
 {
@@ -2645,7 +2437,7 @@
 		if ([pt validDistance])
 		{
 			if (atIdxPtr != 0) *atIdxPtr = idx;
-			return [pt distance];
+			return [pt _distance];
 		}
 		--idx;
 	}
@@ -2653,25 +2445,24 @@
 	return 0.0;
 }
 
-
 - (NSTimeInterval)duration
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcElapsedTime;
     }
     
 	float val = 0.0;
-	if ([overrideData isOverridden:kST_Durations])
-	{
-		val = [overrideData value:kST_Durations index:kElapsed];
+	if ([_overrideData isOverridden:kST_Durations])
+	{
+		val = [_overrideData value:kST_Durations index:kElapsed];
 	}
 	else
 	{
 
 		if ([self usingDeviceLapData])
 		{
-            int numLaps = (int)[laps count];
+            int numLaps = (int)[_laps count];
 			if (numLaps > 0)
 			{
                 float lapDur = 0.0;
@@ -2679,8 +2470,8 @@
                 {
                     for (int i=0; i<numLaps; i++)
                     {
-                        Lap* lap = [laps objectAtIndex:i];
-                        lapDur += [self durationOfLap:lap];
+                        Lap* _lap = [_laps objectAtIndex:i];
+                        lapDur += [self durationOfLap:_lap];
                     }
                 }
 			}
@@ -2696,7 +2487,7 @@
 			val = [self stat:kST_Durations
 					   index:kElapsed
 		   atActiveTimeDelta:0];
-            if (distance == 0 && deviceTotalTime > val)
+            if (_distance == 0 && deviceTotalTime > val)
                 val = deviceTotalTime;
 		}
 		float movingDuration = [self movingDuration];
@@ -2705,7 +2496,7 @@
 			// wall clock duration can never be *less* than 
 			// moving duration.  This can happen due to the way ascent
 			// calculates wall clock duration (difference between last and 
-			// first points), and the way moving time may be used from the
+			// first _points), and the way moving time may be used from the
 			// device itself, as with the 310xt (or other tcx files?)
 			val = movingDuration;
 		}
@@ -2713,7 +2504,6 @@
 	if (val < 0.0) val = 0.0;
 	return val;
 }	
-
 
 - (NSTimeInterval)movingDurationBetweenGoodPoints:(int)sidx end:(int)eidx
 {
@@ -2725,11 +2515,10 @@
 		//      NSDate* fd = [[pts objectAtIndex:sidx] activeTime];
 		//      NSDate* ld = [[pts objectAtIndex:eidx] activeTime];
 		//      answer = [ld timeIntervalSinceDate:fd];
-		answer = [[pts objectAtIndex:eidx] activeTimeDelta] -  [[pts objectAtIndex:sidx] activeTimeDelta];
+		answer = [[pts objectAtIndex:eidx] _activeTimeDelta] -  [[pts objectAtIndex:sidx] _activeTimeDelta];
 	}
 	return answer;
 }
-
 
 - (NSTimeInterval)movingDurationForGraphs
 {
@@ -2737,30 +2526,29 @@
 											 end:((int)[[self goodPoints] count] - 1)];
 }
 
-
 - (NSTimeInterval)movingDuration
 {
-    if (points.count == 0.0)
+    if (_points.count == 0.0)
     {
         return srcMovingTime;
     }
     
 	float val = 0.0;
-	if ([overrideData isOverridden:kST_Durations])
-	{
-		val = [overrideData value:kST_Durations index:kMoving];
+	if ([_overrideData isOverridden:kST_Durations])
+	{
+		val = [_overrideData value:kST_Durations index:kMoving];
 	}
 	else
 	{
-		int numLaps = (int)[laps count];
-        // if distance is 0, then we by definition have no difference between "moving" and "active" time
-        // so add moving duration of laps (which will use "device total time")
-		if ((distance <= 0.0) || ([self usingDeviceLapData] && (numLaps > 0) && (![overrideData isOverridden:kST_Durations])))
+		int numLaps = (int)[_laps count];
+        // if _distance is 0, then we by definition have no difference between "moving" and "active" time
+        // so add moving duration of _laps (which will use "device total time")
+		if ((_distance <= 0.0) || ([self usingDeviceLapData] && (numLaps > 0) && (![_overrideData isOverridden:kST_Durations])))
 		{
 			for (int i=0; i<numLaps; i++)
 			{
-				Lap* lap = [laps objectAtIndex:i];
-				val += [self movingDurationOfLap:lap];
+				Lap* _lap = [_laps objectAtIndex:i];
+				val += [self movingDurationOfLap:_lap];
 			}
 		}
 		else
@@ -2773,30 +2561,29 @@
 	return val;
 }
 
-
-- (NSTimeInterval)movingDurationOfLap:(Lap*)lap
+- (NSTimeInterval)movingDurationOfLap:(Lap*)_lap
 {
 	NSTimeInterval answer = 0.0;
 
-	if ([self usingDeviceLapData] || (distance <= 0.0))
-	{
-        if (FLAG_IS_SET(flags, kHasDeviceTime))
+	if ([self usingDeviceLapData] || (_distance <= 0.0))
+	{
+        if (FLAG_IS_SET(_flags, kHasDeviceTime))
         {
-            answer = [lap deviceTotalTime];
+            answer = [_lap deviceTotalTime];
         }
         else
         {
-            answer = [lap totalTime];
+            answer = [_lap totalTime];
         }
 	}
 	else
 
 	{
-		LapInfo* li = [self getLapInfo:lap];
+		LapInfo* li = [self getLapInfo:_lap];
 		if (li != nil)
 		{
-			int sp = [li startingPointIndex];
-			int np = [li numPoints];
+			int sp = [li _startingPointIndex];
+			int np = [li _numPoints];
 			NSArray* pts = [self goodPoints];
 			int totalPts = (int)[pts count];
 			if (np > 1)
@@ -2805,33 +2592,33 @@
 				int end = sp+np;
 				if (end >= totalPts) end = totalPts-1;
 				TrackPoint* pt = [pts objectAtIndex:sp];
-				NSTimeInterval firstActiveTimeDelta = [pt activeTimeDelta];
-				// add distance between actual start time and lap start time (start point is the first point at or after
+				NSTimeInterval firstActiveTimeDelta = [pt _activeTimeDelta];
+				// add _distance between actual start time and _lap start time (start point is the first point at or after
 				// the start time.
 				if (sp > 0)
 				{
 					TrackPoint* prevpt = [pts objectAtIndex:sp-1];
-					NSTimeInterval activeTimeDeltaTime = [prevpt activeTimeDelta] - firstActiveTimeDelta;
+					NSTimeInterval activeTimeDeltaTime = [prevpt _activeTimeDelta] - firstActiveTimeDelta;
 					NSTimeInterval wallTimeDeltaTime = [prevpt wallClockDelta] - [pt wallClockDelta];
-					if (([prevpt activeTimeDelta] != firstActiveTimeDelta) && (activeTimeDeltaTime == wallTimeDeltaTime))			// only correct mid-point lap moving time start times if active during interval
+					if (([prevpt _activeTimeDelta] != firstActiveTimeDelta) && (activeTimeDeltaTime == wallTimeDeltaTime))			// only correct mid-point _lap moving time start times if active during interval
 					{
-						NSTimeInterval dt = [pt wallClockDelta] - [lap startingWallClockTimeDelta];
+						NSTimeInterval dt = [pt wallClockDelta] - [_lap startingWallClockTimeDelta];
 						off += dt;
 					}
 				}
 				 
 				pt = [pts objectAtIndex:end];
-				NSTimeInterval lastActiveTimeDelta = [pt activeTimeDelta];
-				float lapDur = [self realDurationOfLap:lap];
+				NSTimeInterval lastActiveTimeDelta = [pt _activeTimeDelta];
+				float lapDur = [self realDurationOfLap:_lap];
 				if (end > 0)
 				{
 					TrackPoint* prevpt = [pts objectAtIndex:end-1];
-					NSTimeInterval activeTimeDeltaTime = [prevpt activeTimeDelta] - lastActiveTimeDelta;
+					NSTimeInterval activeTimeDeltaTime = [prevpt _activeTimeDelta] - lastActiveTimeDelta;
 					NSTimeInterval wallTimeDeltaTime = [prevpt wallClockDelta] - [pt wallClockDelta];
-					if ( ([prevpt activeTimeDelta] != lastActiveTimeDelta) && (activeTimeDeltaTime == wallTimeDeltaTime))			// only correct mid-point lap moving time end times if active during interval
+					if ( ([prevpt _activeTimeDelta] != lastActiveTimeDelta) && (activeTimeDeltaTime == wallTimeDeltaTime))			// only correct mid-point _lap moving time end times if active during interval
 					{
-						// subtract time between end point and end lap time (end point is first point *after* the end time);
-						NSTimeInterval dt = [pt wallClockDelta] - ([lap startingWallClockTimeDelta] + lapDur);
+						// subtract time between end point and end _lap time (end point is first point *after* the end time);
+						NSTimeInterval dt = [pt wallClockDelta] - ([_lap startingWallClockTimeDelta] + lapDur);
 						off -= dt;
 					}
 				}
@@ -2840,25 +2627,22 @@
 			}
 			else
 			{
-				answer = [lap totalTime];
+				answer = [_lap totalTime];
 			}
 		}
 	}
 	return answer;
 }
 
-
-- (float) movingSpeedForLap:(Lap*)lap
+- (float) movingSpeedForLap:(Lap*)_lap
 {
 	float answer = 0.0;
-	float totalDist = [self distanceOfLap:lap];
-	NSTimeInterval totalInterval = [self movingDurationOfLap:lap];
+	float totalDist = [self distanceOfLap:_lap];
+	NSTimeInterval totalInterval = [self movingDurationOfLap:_lap];
 	if (totalInterval > 0.0)
 		answer = totalDist/(totalInterval/(60.0*60.0));
 	return answer;
 }   
-
-
 
 - (NSString *)movingDurationAsString
 {
@@ -2869,13 +2653,10 @@
 	return [NSString stringWithFormat:@"%02d:%02d:%02d",hours, mins, secs];
 }
 
-
-
 - (float)durationAsFloat
 {
 	return (float)[self duration];
 }
-
 
 - (void)calcTimeInNonHRZones:(int)type startIdx:(int)sidx endIdx:(int)eidx
 {
@@ -2954,7 +2735,7 @@
 						((type != kPaceDefaults) && (v >= min[zn])))
 					{
 						//cachedNonHRZoneTime[type][zn] += [[nextPt activeTime] timeIntervalSinceDate:[pt activeTime]];
-						cachedNonHRZoneTime[type][zn] += [nextPt activeTimeDelta] - [pt activeTimeDelta];
+						cachedNonHRZoneTime[type][zn] += [nextPt _activeTimeDelta] - [pt _activeTimeDelta];
 						break;
 					}
 				}
@@ -2966,7 +2747,6 @@
 		}
 	}
 }
-
 
 - (void)calcTimeInHRZones:(int)sidx endIdx:(int)eidx
 {
@@ -2995,7 +2775,7 @@
 				if (hr >= min[zn])
 				{
 					//cachedHRZoneTime[zn] += [[nextPt activeTime] timeIntervalSinceDate:[pt activeTime]];
-					cachedHRZoneTime[zn] += ([nextPt activeTimeDelta] - [pt activeTimeDelta]);
+					cachedHRZoneTime[zn] += ([nextPt _activeTimeDelta] - [pt _activeTimeDelta]);
 					break;
 				}
 			}
@@ -3006,7 +2786,6 @@
 		}
 	}
 }
-
 
 - (NSTimeInterval)timeInHRZone:(int)zone
 {
@@ -3015,14 +2794,12 @@
    return cachedHRZoneTime[zone];
 }
 
-
 - (NSTimeInterval)timeInNonHRZone:(int)type zone:(int)zone
 {
 	NSArray* pts = [self goodPoints];
 	[self calcTimeInNonHRZones:type startIdx:0 endIdx:(int)[pts count]-1];
 	return cachedNonHRZoneTime[type][zone];
 }
-
 
    
 - (NSString*)timeInHRZoneAsString:(int)zone
@@ -3043,21 +2820,19 @@
 	return [NSString stringWithFormat:@"%02d:%02d:%02d",hours, mins, secs];
 }
 
-
 - (NSTimeInterval)timeInHRZoneForInterval:(int)zone start:(int)sidx end:(int)eidx;
 {
 	[self calcTimeInHRZones:sidx endIdx:eidx];
 	return cachedHRZoneTime[zone];
 }
 
-
 - (NSTimeInterval)timeInNonHRZoneForInterval:(int)type zone:(int)zone start:(int)sidx end:(int)eidx
 {
 	[self calcTimeInNonHRZones:type startIdx:sidx endIdx:eidx];
 	return cachedNonHRZoneTime[type][zone];
 }
 
-- (NSTimeInterval)timeLapInHRZone:(int)zone lap:(Lap*)lap
+- (NSTimeInterval)timeLapInHRZone:(int)zone _lap:(Lap*)_lap
 {
 	float ret = 0.0;
 	int num = (int)[lapInfoArray count];
@@ -3065,17 +2840,17 @@
 	for (i=0; i<num; i++)
 	{
 		LapInfo* li = [lapInfoArray objectAtIndex:i];
-		if ([li lap] == lap)
-		{
-			int sp = [li startingPointIndex];
-			[self calcTimeInHRZones:sp endIdx:sp + [li numPoints]-1];
+		if ([li _lap] == _lap)
+		{
+			int sp = [li _startingPointIndex];
+			[self calcTimeInHRZones:sp endIdx:sp + [li _numPoints]-1];
 			ret = cachedHRZoneTime[zone];
 		}
 	}
 	return ret;
 }
 
-- (NSTimeInterval)timeLapInNonHRZone:(int)type zone:(int)zone lap:(Lap*)lap
+- (NSTimeInterval)timeLapInNonHRZone:(int)type zone:(int)zone _lap:(Lap*)_lap
 {
 	float ret = 0.0;
 	int num = (int)[lapInfoArray count];
@@ -3083,32 +2858,22 @@
 	for (i=0; i<num; i++)
 	{
 		LapInfo* li = [lapInfoArray objectAtIndex:i];
-		if ([li lap] == lap)
-		{
-			int sp = [li startingPointIndex];
-			[self calcTimeInNonHRZones:type startIdx:sp endIdx:sp + [li numPoints]-1];
+		if ([li _lap] == _lap)
+		{
+			int sp = [li _startingPointIndex];
+			[self calcTimeInNonHRZones:type startIdx:sp endIdx:sp + [li _numPoints]-1];
 			ret = cachedNonHRZoneTime[type][zone];
 		}
 	}
 	return ret;
 }
 
-
-
-
-- (float)weight
+- (float)_weight
 {
    //NSString* s = [self attribute:kWeight];
    //return [s floatValue];
-   return weight;
-}
-
-
-- (void)setWeight:(float)w
-{
-   weight = w;
-}
-
+   return _weight;
+}
 
 - (tLatLonBounds) getLatLonBounds
 {
@@ -3117,10 +2882,10 @@
 	bds.maxLat = kMinPossibleLatitude;
 	bds.minLon = kMaxPossibleLongitude;
 	bds.maxLon = kMinPossibleLongitude;
-	int num = (int)[points count];
+	int num = (int)[_points count];
 	for (int i=0; i<num; i++)
 	{
-		TrackPoint* pt = [points objectAtIndex:i];
+		TrackPoint* pt = [_points objectAtIndex:i];
 		if ([pt validLatLon])
 		{
 			float lat = [pt latitude];
@@ -3134,48 +2899,45 @@
 	return bds;
 }
 
-
 - (float) minLatitude
 {
-   int num = (int)[points count];
+   int num = (int)[_points count];
    int i;
    float min = kMaxPossibleLatitude;
    
    for (i=0; i<num; i++)
    {
-      TrackPoint* pt = [points objectAtIndex:i];
+      TrackPoint* pt = [_points objectAtIndex:i];
       float lat = [pt latitude];
       if ([pt validLatLon] && (lat < min)) min = lat;
    }
    return min;
 }
 
-
 - (float) minLongitude
 {
-   int num = (int)[points count];
+   int num = (int)[_points count];
    int i;
    float min = kMaxPossibleLongitude;
    
    for (i=0; i<num; i++)
    {
-      TrackPoint* pt = [points objectAtIndex:i];
+      TrackPoint* pt = [_points objectAtIndex:i];
       float lon = [pt longitude];
       if ([pt validLatLon] && (lon < min)) min = lon;
    }
    return min;
 }
 
-
 - (float) maxLatitude
 {
-   int num = (int)[points count];
+   int num = (int)[_points count];
    int i;
    float max = kMinPossibleLatitude;
    
    for (i=0; i<num; i++)
    {
-      TrackPoint* pt = [points objectAtIndex:i];
+      TrackPoint* pt = [_points objectAtIndex:i];
       float lat = [pt latitude];
       if ([pt validLatLon] && (lat > max)) max = lat;
    }
@@ -3184,19 +2946,18 @@
 
 - (float) maxLongitude
 {
-   int num = (int)[points count];
+   int num = (int)[_points count];
    int i;
    float max = kMinPossibleLongitude;
    
    for (i=0; i<num; i++)
    {
-      TrackPoint* pt = [points objectAtIndex:i];
+      TrackPoint* pt = [_points objectAtIndex:i];
       float lon = [pt longitude];
       if ([pt validLatLon] && (lon > max)) max = lon;
    }
    return max;
 }
-
 
 - (NSString *)durationAsString
 {
@@ -3206,8 +2967,6 @@
    int secs = (int)dur % 60;
    return [NSString stringWithFormat:@"%02d:%02d:%02d",hours, mins, secs];
 }
-
-
 
 - (void)storeMinMaxAvgStat:(struct tStatData*)data value:(float)val nextValue:(float)nv deltaTime:(float)dt atActiveTimeDelta:(NSTimeInterval)atd atDistance:(float)dist
 {
@@ -3225,11 +2984,10 @@
    data->vals[kAvg] += (val * dt);
 }
 
-
 - (void)calcGradients
 {
    //NSArray *pts = [self goodPoints];
-	NSArray *pts = [self points];
+	NSArray *pts = [self _points];
 	int count = (int)[pts count];
 	if (count > 1)
 	{
@@ -3247,7 +3005,7 @@
 			{
 				hasElevationData = YES;
 				float alt = [pt altitude];
-				float dist = [pt distance];
+				float dist = [pt _distance];
 				dist = dist * 5280.0;   // calculate in feet
 				float deltaDist = (dist - lastDist);
 				if ((deltaDist > 0.0) && (deltaDist >= minGradientDistance) && [pt validAltitude])
@@ -3262,11 +3020,10 @@
 			}
 			[pt setGradient:lastGradient];
 		}
-		if (hasElevationData) SET_FLAG(flags, kHasElevationData);
+		if (hasElevationData) SET_FLAG(_flags, kHasElevationData);
 		
 	}
 }
-
 
 static float sLastAlt;
 
@@ -3291,7 +3048,6 @@
 	}
 	return NO;
 }
-
 
 - (float) calcElapsedTime:(int)startingGoodPoint end:(int)endingGoodPoint
 {
@@ -3318,7 +3074,6 @@
 	kFemaleGender,
 	kMaleGender
 };
-
 
 - (float) calcCalories:(struct tStatData*) statData hrTime:(float)hrTime
 {
@@ -3332,7 +3087,7 @@
 		int gender = [Utils intFromDefaults:RCBDefaultGender];
 		float vO2Max = [Utils floatFromDefaults:RCBDefaultVO2Max];
 		float age = [Utils floatFromDefaults:RCBDefaultAge];
-		float wt = PoundsToKilograms([self weight]);
+		float wt = PoundsToKilograms([self _weight]);
 		// if have vO2Max
 		if (vO2Max > 0.0)
 		{
@@ -3360,7 +3115,7 @@
 	}
 	else
 	{
-		float wt = [self weight];
+		float wt = [self _weight];
 		NSString* activity = [self attribute:kActivity];
 		NSRange range = [activity rangeOfString:@"cycling"
 										options:NSCaseInsensitiveSearch];
@@ -3377,25 +3132,24 @@
 	return answer;
 }
 
-
 #define MIN_HR             10.0
 #define MAX_HR_DELTA_SECS  90.0
 
 - (void)calculateStats:(struct tStatData*)sArray startIdx:(int)startingGoodIdx endIdx:(int)endingGoodIdx
 {
 	NSArray* goodPts = [self goodPoints];
-	NSArray* pts = [self points];
+	NSArray* pts = [self _points];
 	
-    int numPoints = (int)[pts count];
+    int _numPoints = (int)[pts count];
     int numGoodPoints = (int)[goodPoints count];
 	if (!(IS_BETWEEN(0, startingGoodIdx, numGoodPoints)) ||
 		!(IS_BETWEEN(0, endingGoodIdx, numGoodPoints))) return;		// nothing to do here;
 	
-	// must see "dead interval" markers to calculate things correctly...so convert from "good point array" indices to
+	// must see "dead interval" _markers to calculate things correctly...so convert from "good point array" indices to
 	// normal "point array" indices
 	int sidx = (startingGoodIdx == 0) ? 0 : (int)[pts indexOfObjectIdenticalTo:[goodPts objectAtIndex:startingGoodIdx]];
-	int eidx = (endingGoodIdx >= (numGoodPoints - 1)) ? (numPoints - 1) : (int)[pts indexOfObjectIdenticalTo:[goodPts objectAtIndex:endingGoodIdx]];
-	if ((numPoints > 1) && (sidx <= eidx) && (sidx >= 0) && (eidx < numPoints))
+	int eidx = (endingGoodIdx >= (numGoodPoints - 1)) ? (_numPoints - 1) : (int)[pts indexOfObjectIdenticalTo:[goodPts objectAtIndex:endingGoodIdx]];
+	if ((_numPoints > 1) && (sidx <= eidx) && (sidx >= 0) && (eidx < _numPoints))
 	{
 		int i;
 
@@ -3446,10 +3200,10 @@
 		//NSTimeInterval lastTime = [[pt date] timeIntervalSince1970];
 		// NSTimeInterval lastActiveTime = [[pt activeTime] timeIntervalSince1970];
 		NSTimeInterval lastTime = [pt wallClockDelta];
-		NSTimeInterval lastActiveTime = [pt activeTimeDelta];
+		NSTimeInterval lastActiveTime = [pt _activeTimeDelta];
 		BOOL lastPointWasDeadMarker = NO;
 		TrackPoint* nxtpt;
-		BOOL entireTrack = (sidx == 0) && (eidx == (numPoints-1));
+		BOOL entireTrack = (sidx == 0) && (eidx == (_numPoints-1));
 		float startClimb = 0.0;
 		float startDescent = 0.0;
 		float endClimb = 0.0;
@@ -3465,7 +3219,7 @@
 			//nextTime = [[nxtpt date] timeIntervalSince1970];
 			//nextActiveTime = [[nxtpt activeTime] timeIntervalSince1970];
 			nextTime = [nxtpt wallClockDelta];
-			nextActiveTime = [nxtpt activeTimeDelta];
+			nextActiveTime = [nxtpt _activeTimeDelta];
 			if ([pt isDeadZoneMarker])
 			{
 				lastPointWasDeadMarker = YES;
@@ -3477,7 +3231,7 @@
 				totalTime += dt;
 				totalActiveTime += deltaActiveTime;
 				//NSDate* g = [pt activeTime];
-				//NSDate* ptDate = [[self creationTime] addTimeInterval:[pt activeTimeDelta]];
+				//NSDate* ptDate = [[self _creationTime] addTimeInterval:[pt _activeTimeDelta]];
 				// calculate total climb + descent
 				float alt = [pt altitude];
 				if (entireTrack) 
@@ -3488,7 +3242,7 @@
 								  climbData:climbData])
 					{
 					}
-					[pt setClimbSoFar:climbData->vals[kMax] ];		// set even on deadzone markers
+					[pt setClimbSoFar:climbData->vals[kMax] ];		// set even on deadzone _markers
 					[pt setDescentSoFar:climbData->vals[kMin]];
 				}
 				if ((i >= sidx) && !haveStartedAlt) 
@@ -3507,8 +3261,8 @@
 									   value:alt 
 								   nextValue:(nextPointIsDeadZoneMarker ? alt : [nxtpt altitude])
 								   deltaTime:dt
-						   atActiveTimeDelta:[pt activeTimeDelta]
-								  atDistance:[pt distance]];
+						   atActiveTimeDelta:[pt _activeTimeDelta]
+								  atDistance:[pt _distance]];
 				}
 
 				// gradient
@@ -3517,8 +3271,8 @@
 								   value:gradient 
 							   nextValue:(nextPointIsDeadZoneMarker ? gradient : [nxtpt gradient])
 							   deltaTime:deltaActiveTime              // uses ACTIVE time
-					   atActiveTimeDelta:[pt activeTimeDelta]
-							  atDistance:[pt distance]];
+					   atActiveTimeDelta:[pt _activeTimeDelta]
+							  atDistance:[pt _distance]];
             
 				// heartrate
 				float hr = [pt heartrate];
@@ -3528,8 +3282,8 @@
 									  value:hr 
 								  nextValue:(nextPointIsDeadZoneMarker ? hr : [nxtpt heartrate])
 								  deltaTime:dt
-						  atActiveTimeDelta:[pt activeTimeDelta]
-								 atDistance:[pt distance]];
+						  atActiveTimeDelta:[pt _activeTimeDelta]
+								 atDistance:[pt _distance]];
 				   hrTime += dt;
 				}
 				// speed
@@ -3538,8 +3292,8 @@
 								   value:speed 
 							   nextValue:(nextPointIsDeadZoneMarker ? speed : [nxtpt speed])
 							   deltaTime:dt
-					   atActiveTimeDelta:[pt activeTimeDelta]
-							  atDistance:[pt distance]];
+					   atActiveTimeDelta:[pt _activeTimeDelta]
+							  atDistance:[pt _distance]];
 
 				if (speed > speedThreshold)
 				{
@@ -3547,8 +3301,8 @@
 									  value:speed 
 								  nextValue:(nextPointIsDeadZoneMarker ? speed : [nxtpt speed])
 								  deltaTime:dt
-						  atActiveTimeDelta:[pt activeTimeDelta]
-								 atDistance:[pt distance]];
+						  atActiveTimeDelta:[pt _activeTimeDelta]
+								 atDistance:[pt _distance]];
 				   spdTime += dt;
 				}
 				// cadence
@@ -3559,8 +3313,8 @@
 									  value:cad 
 								  nextValue:(nextPointIsDeadZoneMarker ? cad : [nxtpt cadence])
 								  deltaTime:deltaActiveTime         // uses ACTIVE time
-						  atActiveTimeDelta:[pt activeTimeDelta]
-								 atDistance:[pt distance]];
+						  atActiveTimeDelta:[pt _activeTimeDelta]
+								 atDistance:[pt _distance]];
 				   cadTime += deltaActiveTime;
 				   hasCadence = YES;
 				}
@@ -3572,8 +3326,8 @@
 									   value:power 
 								   nextValue:(nextPointIsDeadZoneMarker ? power : [nxtpt power])
 								   deltaTime:deltaActiveTime         // uses ACTIVE time
-						   atActiveTimeDelta:[pt activeTimeDelta]
-								  atDistance:[pt distance]];
+						   atActiveTimeDelta:[pt _activeTimeDelta]
+								  atDistance:[pt _distance]];
 					pwrTime += deltaActiveTime;
 					hasPower = YES;
 				}
@@ -3585,8 +3339,8 @@
 									   value:temperature 
 								   nextValue:(nextPointIsDeadZoneMarker ? cad : [nxtpt temperature])
 								   deltaTime:deltaActiveTime         // uses ACTIVE time
-						   atActiveTimeDelta:[pt activeTimeDelta]
-								  atDistance:[pt distance]];
+						   atActiveTimeDelta:[pt _activeTimeDelta]
+								  atDistance:[pt _distance]];
 					temperatureTime += deltaActiveTime;
 					hasTemperature = YES;
 				}
@@ -3596,7 +3350,7 @@
 			lastActiveTime = nextActiveTime;
 		}
 		i = eidx+1;
-		while (i < (numPoints-1))
+		while (i < (_numPoints-1))
 		{
 		 TrackPoint* pt = [pts objectAtIndex:i];
 		 if (/*[pt validAltitude]*/ ![pt isDeadZoneMarker])
@@ -3611,12 +3365,12 @@
 		climbData->vals[kMin] = endDescent - startDescent;
 		if (totalTime > 0.0) altData->vals[kAvg] /= totalTime;
 		if (hrTime > 0.0) hrData->vals[kAvg] /= hrTime;  else hrData->vals[kAvg] = hrData->vals[kMin] = 0.0;
-		// calculate average gradient using start and end points, rather than the normal
+		// calculate average gradient using start and end _points, rather than the normal
 		// 'moving' average calculated above.  This was a bug report.
 		//TrackPoint* spt = [pts objectAtIndex:sidx];
 		//TrackPoint* ept = [pts objectAtIndex:eidx];
-		//float sdist = [spt distance] * 5280;	// miles to feet
-		//float edist = [ept distance] * 5280;
+		//float sdist = [spt _distance] * 5280;	// miles to feet
+		//float edist = [ept _distance] * 5280;
 		if (cadTime > 0.0) cadData->vals[kAvg] /= cadTime; else cadData->vals[kAvg] = cadData->vals[kMin] = 0.0;
 		if (pwrTime > 0.0) pwrData->vals[kAvg] /= pwrTime; else pwrData->vals[kAvg] = pwrData->vals[kMin] = 0.0;
 		if (temperatureTime > 0.0) temperatureData->vals[kAvg] /= temperatureTime; 
@@ -3671,9 +3425,9 @@
 -(float)getTotalDistanceUsingLaps
 {
 	float td = 0.0;
-	if (laps && [laps count] > 0)
-	{
-		NSNumber* num = [laps valueForKeyPath:@"@sum.distance"];
+	if (_laps && [_laps count] > 0)
+	{
+		NSNumber* num = [_laps valueForKeyPath:@"@sum.distance"];
 		td = [num floatValue];
 	}
 	return td;
@@ -3689,29 +3443,29 @@
 			[self calculateStats:statsArray startIdx:0 endIdx:(int)[[self goodPoints] count]-1];
 			// fill in other stats not
 			struct tStatData* distData = &statsArray[kST_Distance];
-			if (distance <= 0.0)
-				distance = [self getTotalDistanceUsingLaps];
-			distData->vals[kVal] = distance;
+			if (_distance <= 0.0)
+				_distance = [self getTotalDistanceUsingLaps];
+			distData->vals[kVal] = _distance;
 			// override the normal 'average' calculation for moving speed, and just 
-			// divide distance by moving duration
-			// plug in calorie data, for now we get it from laps (Garmin calculation) @@FIXME@@
+			// divide _distance by moving duration
+			// plug in calorie data, for now we get it from _laps (Garmin calculation) @@FIXME@@
 			//struct tStatData* calData = &statsArray[kST_Calories];
-			//NSNumber* num = [laps valueForKeyPath:@"@sum.calories"];
+			//NSNumber* num = [_laps valueForKeyPath:@"@sum.calories"];
 			//calData->vals[kVal] = [num floatValue];
 		}
 		else
 		{
-			// no points; fill in what we can from laps, if they exists
-			if (laps && [laps count] > 0)
+			// no _points; fill in what we can from _laps, if they exists
+			if (_laps && [_laps count] > 0)
 			{
 				float totalDistance = [self getTotalDistanceUsingLaps];
 				statsArray[kST_Distance].vals[kVal] = totalDistance;
-				statsArray[kST_Heartrate].vals[kMax] = [[laps valueForKeyPath:@"@max.maxHeartRate"] floatValue];
-				statsArray[kST_Heartrate].vals[kAvg] = [[laps valueForKeyPath:@"@avg.averageHeartRate"] floatValue];	// @@FIMXE@@ (incorporate time)
-				statsArray[kST_Cadence].vals[kAvg] = [[laps valueForKeyPath:@"@avg.averageCadence"] floatValue];	// @@FIMXE@@ (incorporate time)
-				statsArray[kST_Speed].vals[kMax] = statsArray[kST_MovingSpeed].vals[kMax] = [[laps valueForKeyPath:@"@max.maxSpeed"] floatValue];	
-				statsArray[kST_Calories].vals[kVal] = [[laps valueForKeyPath:@"@sum.calories"] floatValue];
-				float totalTime = [[laps  valueForKeyPath:@"@sum.totalTime"] floatValue];
+				statsArray[kST_Heartrate].vals[kMax] = [[_laps valueForKeyPath:@"@max.maxHeartRate"] floatValue];
+				statsArray[kST_Heartrate].vals[kAvg] = [[_laps valueForKeyPath:@"@avg.averageHeartRate"] floatValue];	// @@FIMXE@@ (incorporate time)
+				statsArray[kST_Cadence].vals[kAvg] = [[_laps valueForKeyPath:@"@avg.averageCadence"] floatValue];	// @@FIMXE@@ (incorporate time)
+				statsArray[kST_Speed].vals[kMax] = statsArray[kST_MovingSpeed].vals[kMax] = [[_laps valueForKeyPath:@"@max.maxSpeed"] floatValue];	
+				statsArray[kST_Calories].vals[kVal] = [[_laps valueForKeyPath:@"@sum.calories"] floatValue];
+				float totalTime = [[_laps  valueForKeyPath:@"@sum.totalTime"] floatValue];
 				statsArray[kST_Durations].vals[kElapsed] = statsArray[kST_Durations].vals[kMoving] = totalTime;
 				if (totalTime > 0.0)
 				{
@@ -3720,8 +3474,8 @@
 			}
             else
             {
-                // no points data yet, use anything stored in track
-                float totalDistance = [self distance];
+                // no _points data yet, use anything stored in track
+                float totalDistance = [self _distance];
                 statsArray[kST_Distance].vals[kVal] = totalDistance;
                 statsArray[kST_Heartrate].vals[kMax] = [self maxHeartrate:nil];
                 statsArray[kST_Heartrate].vals[kAvg] = [self avgHeartrate];
@@ -3730,14 +3484,13 @@
                 statsArray[kST_Power].vals[kMax] = [self maxPower:nil];
                 statsArray[kST_Speed].vals[kMax] = [self avgSpeed];
                 statsArray[kST_MovingSpeed].vals[kMax] = [self maxSpeed:nil];
-                ///statsArray[kST_Calories].vals[kVal] = [[laps valueForKeyPath:@"@sum.calories"] floatValue];
+                ///statsArray[kST_Calories].vals[kVal] = [[_laps valueForKeyPath:@"@sum.calories"] floatValue];
                 statsArray[kST_Durations].vals[kElapsed] = [self duration];
                 statsArray[kST_Durations].vals[kMoving] = [self movingDuration];
             }
 		}
 	}
 }
-
 
 - (void)invalidateStats
 {
@@ -3750,20 +3503,18 @@
    [self invalidateAllLapStats];
 }
 
-
 - (struct tStatData*) getStat:(int)type
 {
 	[self calculateTrackStats];
 	return &statsArray[type];
 }
 
-
 - (float)stat:(tStatType)stat index:(int)idx atActiveTimeDelta:(NSTimeInterval*)atTime 
 {
 	float val;
-	if ([overrideData isOverridden:stat])
-	{
-		val = [overrideData value:stat index:idx];
+	if ([_overrideData isOverridden:stat])
+	{
+		val = [_overrideData value:stat index:idx];
 	}
 	else
 	{
@@ -3777,13 +3528,12 @@
 	return val;
 }	
 
-
 -(float)statOrOverride:(tStatType)stype index:(int)idx atActiveTimeDelta:(NSTimeInterval*)atTime
 {
 	float val;
-	if ([overrideData isOverridden:stype])
-	{
-		val = [overrideData value:stype 
+	if ([_overrideData isOverridden:stype])
+	{
+		val = [_overrideData value:stype 
 							index:idx];
 		///if (atTime) *atTime = nil;
 	}
@@ -3796,22 +3546,21 @@
 	return val;
 }
 
-
-- (float)distance
+- (float)_distance
 {
 	float val = 0.0;
-    NSUInteger numLaps = laps ? [laps count] : 0;
-	if ([self usingDeviceLapData] && (numLaps > 0) && (![overrideData isOverridden:kST_Distance]))
+    NSUInteger numLaps = _laps ? [_laps count] : 0;
+	if ([self usingDeviceLapData] && (numLaps > 0) && (![_overrideData isOverridden:kST_Distance]))
 	{
 		for (int i=0; i<numLaps; i++)
 		{
-			Lap* lap = [laps objectAtIndex:i];
-			val += [self distanceOfLap:lap];
-		}
-	}
-	else if ([points count] == 0)
+			Lap* _lap = [_laps objectAtIndex:i];
+			val += [self distanceOfLap:_lap];
+		}
+	}
+	else if ([_points count] == 0)
     {
-        return distance;
+        return _distance;
     }
     else
 	{
@@ -3822,17 +3571,16 @@
 	return val;
 }
 
-
 - (float)maxSpeed
 {
 	float val = 0.0;
-    NSUInteger numLaps = laps ? [laps count] : 0;
-	if ([self usingDeviceLapData] && (numLaps > 0) && (![overrideData isOverridden:kST_Distance]))
+    NSUInteger numLaps = _laps ? [_laps count] : 0;
+	if ([self usingDeviceLapData] && (numLaps > 0) && (![_overrideData isOverridden:kST_Distance]))
 	{
 		for (int i=0; i<numLaps; i++)
 		{
-			Lap* lap = [laps objectAtIndex:i];
-			float ms = [lap maxSpeed];
+			Lap* _lap = [_laps objectAtIndex:i];
+			float ms = [_lap maxSpeed];
 			if (ms > val) val = ms;
 		}
 	}
@@ -3845,10 +3593,9 @@
 	return val;
 }
 
-
 - (float)maxSpeed:(NSTimeInterval*)atTime
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcMaxSpeed;
     }
@@ -3857,33 +3604,31 @@
 						 atActiveTimeDelta:atTime];
 }
 
-
 - (float)avgSpeed
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcElapsedTime ? srcDistance/(srcElapsedTime/3600.0) : 0.0;
     }
    NSTimeInterval dur = [self duration];
    if (dur != 0.0)
    {
-      float dist = [self distance];
+      float dist = [self _distance];
       return dist/(((float)dur)/3600.);
    }
    return 0.0;
 }
 
-
 - (float)avgMovingSpeed
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcMovingTime ? srcDistance/(srcMovingTime/3600.0) : 0.0;
     }
 	float val;
-	if ([overrideData isOverridden:kST_MovingSpeed])
-	{
-		val = [overrideData value:kST_MovingSpeed 
+	if ([_overrideData isOverridden:kST_MovingSpeed])
+	{
+		val = [_overrideData value:kST_MovingSpeed 
 							index:kAvg];
 	}
 	else
@@ -3892,13 +3637,12 @@
 		NSTimeInterval dur = [self movingDuration];
 		if (dur != 0.0)
 		{
-			float dist = [self distance];
+			float dist = [self _distance];
 			val = dist/(((float)dur)/3600.);
 		}
 	}
 	return val;
 }
-
 
 - (float)minPace:(NSTimeInterval*)atTime
 {
@@ -3912,7 +3656,6 @@
 	}
 	return val;
 }
-
 
 - (float)avgPace
 {
@@ -3928,7 +3671,6 @@
 	return val;
 }
 
-
 - (float)avgMovingPace
 {
 	//float val = [self statOrOverride:kST_MovingSpeed
@@ -3943,17 +3685,16 @@
 	return val;
 }
 
-
 - (float)calories
 {
 	float answer = 0.0;
-	int numLaps = laps ? (int)[laps count] : 0;
-	if ([self usingDeviceLapData] && (numLaps > 0) && (![overrideData isOverridden:kST_Distance]))
+	int numLaps = _laps ? (int)[_laps count] : 0;
+	if ([self usingDeviceLapData] && (numLaps > 0) && (![_overrideData isOverridden:kST_Distance]))
 	{
 		for (int i=0; i<numLaps; i++)
 		{
-			Lap* lap = [laps objectAtIndex:i];
-			answer += [self caloriesForLap:lap];
+			Lap* _lap = [_laps objectAtIndex:i];
+			answer += [self caloriesForLap:_lap];
 		}
 	}
 	else
@@ -3965,11 +3706,9 @@
 	return answer;
 }
 
-
-
 - (float)maxAltitude:(NSTimeInterval*)atTime
 {
-    if (points.count ==0)
+    if (_points.count ==0)
     {
         return srcMaxElevation;
     }
@@ -3978,10 +3717,9 @@
 						 atActiveTimeDelta:atTime];
 }
 
-
 - (float)minAltitude:(NSTimeInterval*)atTime
 {
-    if (points.count ==0)
+    if (_points.count ==0)
     {
         return srcMinElevation;
     }
@@ -3997,23 +3735,22 @@
 			  atActiveTimeDelta:0];
 }
 
-
 - (float)maxHeartrate:(NSTimeInterval*)atTime
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcMaxHeartrate;
     }
     
 	float val = 0.0;
-	int numLaps = laps ? (int)[laps count] : 0;
-	BOOL useLapData = ([self usingDeviceLapData] && (numLaps > 0) && (![overrideData isOverridden:kST_Heartrate]));
+	int numLaps = _laps ? (int)[_laps count] : 0;
+	BOOL useLapData = ([self usingDeviceLapData] && (numLaps > 0) && (![_overrideData isOverridden:kST_Heartrate]));
 	if (useLapData)
 	{
 		for (int i=0; i<numLaps; i++)
 		{
-			Lap* lap = [laps objectAtIndex:i];
-			float max = [lap maxHeartRate];
+			Lap* _lap = [_laps objectAtIndex:i];
+			float max = [_lap maxHeartRate];
 			if (max > val) val = max;
 		}
 	}
@@ -4026,7 +3763,6 @@
 	return val;
 }
 
-
 - (float)minHeartrate:(NSTimeInterval*)atTime
 {
 	return [self statOrOverride:kST_Heartrate
@@ -4034,10 +3770,9 @@
 			  atActiveTimeDelta:atTime];
 }
 
-
 - (float)avgHeartrate
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcAvgHeartrate;
     }
@@ -4047,7 +3782,6 @@
 						 atActiveTimeDelta:0];
 }
 
-
 - (float)maxGradient:(NSTimeInterval*)atTime
 {
 	return [self statOrOverride:kST_Gradient
@@ -4055,7 +3789,6 @@
 						 atActiveTimeDelta:atTime];
 }
 
-
 - (float)minGradient:(NSTimeInterval*)atTime
 {
 	return [self statOrOverride:kST_Gradient
@@ -4063,8 +3796,6 @@
 						 atActiveTimeDelta:atTime];
 }
 
-
-
 - (float)maxTemperature:(NSTimeInterval*)atTime
 {
 	return [self statOrOverride:kST_Temperature
@@ -4072,7 +3803,6 @@
 			  atActiveTimeDelta:atTime];
 }
 
-
 - (float)minTemperature:(NSTimeInterval*)atTime
 {
 	return [self statOrOverride:kST_Temperature
@@ -4080,8 +3810,6 @@
 			  atActiveTimeDelta:atTime];
 }
 
-
-
 - (float)avgGradient
 {
 	return [self statOrOverride:kST_Gradient
@@ -4089,10 +3817,9 @@
 						 atActiveTimeDelta:0];
 }
 
-
 - (float)avgTemperature
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcAvgTemperature;
     }
@@ -4101,7 +3828,6 @@
 			  atActiveTimeDelta:0];
 }
 
-
 - (float)maxCadence:(NSTimeInterval*)atTime
 {
 	return [self statOrOverride:kST_Cadence
@@ -4109,10 +3835,9 @@
 			  atActiveTimeDelta:atTime];
 }
 
-
 - (float)avgCadence
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcAvgCadence;
     }
@@ -4121,23 +3846,21 @@
 						 atActiveTimeDelta:0];
 }
 
-
 -(void)setEnableCalculationOfPower:(BOOL)en
 {
 	if (en)
 	{
-		CLEAR_FLAG(flags, kDontCalculatePower);
+		CLEAR_FLAG(_flags, kDontCalculatePower);
 	}
 	else
 	{
-		SET_FLAG(flags, kDontCalculatePower);
-	}
-}
-
+		SET_FLAG(_flags, kDontCalculatePower);
+	}
+}
 
 -(BOOL)calculationOfPowerEnabled
 {
-	return FLAG_IS_SET(flags, kDontCalculatePower);
+	return FLAG_IS_SET(_flags, kDontCalculatePower);
 }
 
 -(BOOL)activityIsValidForPowerCalculation
@@ -4146,7 +3869,6 @@
 	NSArray* powerActs = [Utils objectFromDefaults:RCBDefaultCalculatePowerActivities];
 	return [self hasDevicePower] || (powerActs && [powerActs containsObject:act]);
 }
-
 
 -(void)calculatePower
 {
@@ -4158,9 +3880,9 @@
 		float gravConst = 9.8;
 		float rollingResistance = 0.0053;
 		float drag = 0.185;
-		float bikeWeight = PoundsToKilograms(equipmentWeight);
+		float bikeWeight = PoundsToKilograms(_equipmentWeight);
 #if ASCENT_DBG
-		///printf("equipment weight for power calculations: %0.1f kg\n", bikeWeight); 
+		///printf("equipment _weight for power calculations: %0.1f kg\n", bikeWeight); 
 #endif
 		BOOL calcPower = [self activityIsValidForPowerCalculation];
 		for (int i=0; i<num; i++)
@@ -4174,13 +3896,13 @@
 				if (!hasCadence || (IS_BETWEEN(0.0, cadence, 254.0)))
 				{
 					float spd = MilesToKilometers([pt speed]) * (10.0/36.0);	// convert to m/sec
-					float wt = PoundsToKilograms([self weight]) + bikeWeight;
+					float wt = PoundsToKilograms([self _weight]) + bikeWeight;
 					p = (gravConst * wt * spd * (rollingResistance + ([pt gradient]/100.0))) + (drag*spd*spd*spd);
 				}
 			}
 			[pt setCalculatedPower:p];
 		}
-		SET_FLAG(flags, kPowerDataCalculatedOrZeroed);
+		SET_FLAG(_flags, kPowerDataCalculatedOrZeroed);
 		if (!calcPower && peakIntervalData) 
 		{
 			free(peakIntervalData);
@@ -4191,35 +3913,26 @@
 	}
 }
 
-
--(void)setEquipmentWeight:(float)iw
-{
-	equipmentWeight = iw;
-	CLEAR_FLAG(flags, kPowerDataCalculatedOrZeroed);
-}
-
 -(void)setStaleEquipmentAttr:(BOOL)v
 {
 	if (v)
 	{
-		SET_FLAG(flags, kEquipmentAttrStale);
+		SET_FLAG(_flags, kEquipmentAttrStale);
 	}
 	else
 	{
-		CLEAR_FLAG(flags, kEquipmentAttrStale);
-	}
-}
-
+		CLEAR_FLAG(_flags, kEquipmentAttrStale);
+	}
+}
 
 -(BOOL)staleEquipmentAttr
 {
-	return FLAG_IS_SET(flags, kEquipmentAttrStale);
-}
-
+	return FLAG_IS_SET(_flags, kEquipmentAttrStale);
+}
 
 -(void)checkPowerData
 {
-	if (![self hasDevicePower] && (!FLAG_IS_SET(flags, kPowerDataCalculatedOrZeroed)))
+	if (![self hasDevicePower] && (!FLAG_IS_SET(_flags, kPowerDataCalculatedOrZeroed)))
 	{
 		[self calculatePower];
 	}
@@ -4227,7 +3940,7 @@
 
 - (float)maxPower:(NSTimeInterval*)atTime
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcMaxPower;
     }
@@ -4237,10 +3950,9 @@
 			  atActiveTimeDelta:atTime];
 }
 
-
 - (float)avgPower
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcAvgPower;
     }
@@ -4250,18 +3962,16 @@
 			  atActiveTimeDelta:0];
 }
 
-
-
 - (float)work
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcKilojoules;
     }
 	float val = 0.0;
-	if ([overrideData isOverridden:kST_Power])
-	{
-		val = [overrideData value:kST_Power 
+	if ([_overrideData isOverridden:kST_Power])
+	{
+		val = [_overrideData value:kST_Power 
 							index:kWork];
 	}
 	else
@@ -4271,10 +3981,9 @@
 	return val;
 }
 
-
 - (float)totalClimb
 {
-    if (points.count == 0)
+    if (_points.count == 0)
     {
         return srcTotalClimb;
     }
@@ -4283,7 +3992,6 @@
                     atActiveTimeDelta:0];
 }
 
-
 - (float)totalDescent
 {
 	return [self statOrOverride:kST_ClimbDescent
@@ -4291,17 +3999,15 @@
 						 atActiveTimeDelta:0];
 }
 
-
 - (BOOL)isDateDuringTrack:(NSDate*)d
 {
-	NSDate* cdt = [self creationTime];
+	NSDate* cdt = [self _creationTime];
 	NSDate* endDate = [[NSDate alloc] initWithTimeInterval:[self duration] sinceDate:cdt];
 	BOOL isLessThan = [d compare:cdt] == NSOrderedAscending;
 	BOOL isGreaterThan = [d compare:endDate] == NSOrderedDescending;
 	return ((isLessThan == NO) && (isGreaterThan == NO));
 }
 
-
 -(float) firstValidLatitude
 {
 	NSMutableArray* pts = [self goodPoints];
@@ -4317,7 +4023,6 @@
 	return BAD_LATLON;
 }
 
-
 -(float) firstValidLongitude
 {
 	NSMutableArray* pts = [self goodPoints];
@@ -4333,10 +4038,9 @@
 	return BAD_LATLON;
 }
 
-
 -(float) firstValidAltitude:(int)sidx
 {
-	NSMutableArray* pts = [self points];
+	NSMutableArray* pts = [self _points];
 	int i;
 	for (i=sidx; i<[pts count]; i++)
 	{
@@ -4349,10 +4053,9 @@
 	return BAD_ALTITUDE;
 }
 
-
 -(float) lastValidAltitude:(int)eidx
 {
-	NSMutableArray* pts = [self points];
+	NSMutableArray* pts = [self _points];
 	int i;
 	for (i=eidx; i>=0; i--)
 	{
@@ -4365,26 +4068,24 @@
 	return BAD_ALTITUDE;
 }
 
-
 -(float) firstValidDistance:(int)sidx
 {
-	NSMutableArray* pts = [self points];
+	NSMutableArray* pts = [self _points];
 	int i;
 	for (i=sidx; i<[pts count]; i++)
 	{
 		TrackPoint* pt = [pts objectAtIndex:i];
 		if ([pt validDistance])
 		{
-			return [pt distance];
+			return [pt _distance];
 		}
 	}
 	return BAD_DISTANCE;
 }
 
-
 -(float) firstValidOrigDistance:(int)sidx
 {
-	NSMutableArray* pts = [self points];
+	NSMutableArray* pts = [self _points];
 	int i;
 	for (i=sidx; i<[pts count]; i++)
 	{
@@ -4397,22 +4098,20 @@
 	return BAD_DISTANCE;
 }
 
-
 -(float) lastValidDistance:(int)eidx
 {
-	NSMutableArray* pts = [self points];
+	NSMutableArray* pts = [self _points];
 	int i;
 	for (i=eidx; i>=0; i--)
 	{
 		TrackPoint* pt = [pts objectAtIndex:i];
 		if ([pt validDistance])
 		{
-			return [pt distance];
+			return [pt _distance];
 		}
 	}
 	return BAD_DISTANCE;
 }
-
 
 -(float) firstValidAltitudeUsingGoodPoints:(int)sidx
 {
@@ -4429,7 +4128,6 @@
 	return BAD_ALTITUDE;
 }
 
-
 -(TrackPoint*) closestPointToDistance:(float)d
 {
 	NSMutableArray* pts = [self goodPoints];
@@ -4437,7 +4135,7 @@
 	for (i=0; i<[pts count]; i++)
 	{
 		TrackPoint* pt = [pts objectAtIndex:i];
-		if (([pt validLatLon]) && ([pt distance] >= d))
+		if (([pt validLatLon]) && ([pt _distance] >= d))
 		{
 			return pt;
 		}
@@ -4445,131 +4143,114 @@
 	return nil;
 }
 
-
 - (void) setUseOrigDistance:(BOOL)yn
 {
 	if (yn) 
 	{
-		SET_FLAG(flags, kUseOrigDistance);
+		SET_FLAG(_flags, kUseOrigDistance);
 	}
 	else
 	{
-		CLEAR_FLAG(flags, kUseOrigDistance);
-	}
-}
-
+		CLEAR_FLAG(_flags, kUseOrigDistance);
+	}
+}
 
 - (BOOL) useOrigDistance
 {
-	return FLAG_IS_SET(flags, kUseOrigDistance);
-}
-
+	return FLAG_IS_SET(_flags, kUseOrigDistance);
+}
 
 -(BOOL)usingDeviceLapData
 {
-	return FLAG_IS_SET(flags, kUseDeviceLapData);
-}
-
+	return FLAG_IS_SET(_flags, kUseDeviceLapData);
+}
 
 -(void)setUseDeviceLapData:(BOOL)use
 {
 	if (use) 
 	{
-		SET_FLAG(flags, kUseDeviceLapData);
+		SET_FLAG(_flags, kUseDeviceLapData);
 	}
 	else
 	{
-		CLEAR_FLAG(flags, kUseDeviceLapData);
-	}
-}
-
+		CLEAR_FLAG(_flags, kUseDeviceLapData);
+	}
+}
 
 -(void)setHasDeviceTime:(BOOL)has
 {
 	if (has) 
 	{
-		SET_FLAG(flags, kHasDeviceTime);
+		SET_FLAG(_flags, kHasDeviceTime);
 	}
 	else
 	{
-		CLEAR_FLAG(flags, kHasDeviceTime);
-	}
-}
-
+		CLEAR_FLAG(_flags, kHasDeviceTime);
+	}
+}
 
 -(void)setHasCadence:(BOOL)has
 {
 	if (has)
 	{
-		SET_FLAG(flags, kHasCadenceData);
+		SET_FLAG(_flags, kHasCadenceData);
 	}
 	else
 	{
-		CLEAR_FLAG(flags, kHasCadenceData);
-	}
-}
-
+		CLEAR_FLAG(_flags, kHasCadenceData);
+	}
+}
 
 -(BOOL)hasCadence
 {
-	return FLAG_IS_SET(flags, kHasCadenceData);
-}
-
+	return FLAG_IS_SET(_flags, kHasCadenceData);
+}
 
 -(BOOL)hasExplicitDeadZones
 {
-    return FLAG_IS_SET(flags, kHasExplicitDeadZones);
-}
-
+    return FLAG_IS_SET(_flags, kHasExplicitDeadZones);
+}
 
 -(void)setHasExplicitDeadZones:(BOOL)has
 {
     if (has)
     {
-        SET_FLAG(flags, kHasExplicitDeadZones);
+        SET_FLAG(_flags, kHasExplicitDeadZones);
     }
     else
     {
-        CLEAR_FLAG(flags, kHasExplicitDeadZones);
+        CLEAR_FLAG(_flags, kHasExplicitDeadZones);
     }
 }
 
-
-
 //---- Power-related -----------------------------------------------------------
 
 -(void)setHasDevicePower:(BOOL)has
 {
 	if (has)
 	{
-		SET_FLAG(flags, kHasDevicePowerData);
+		SET_FLAG(_flags, kHasDevicePowerData);
 	}
 	else
 	{
-		CLEAR_FLAG(flags, kHasDevicePowerData);
-	}
-}
-
+		CLEAR_FLAG(_flags, kHasDevicePowerData);
+	}
+}
 
 -(BOOL)hasDevicePower
 {
-	return FLAG_IS_SET(flags, kHasDevicePowerData);
-}
-
+	return FLAG_IS_SET(_flags, kHasDevicePowerData);
+}
 
 -(BOOL)hasElevationData
 {
-	return FLAG_IS_SET(flags, kHasElevationData);
-}
-
+	return FLAG_IS_SET(_flags, kHasElevationData);
+}
 
 -(BOOL)hasLocationData
 {
-	return FLAG_IS_SET(flags, kHasLocationData);
-}
-
-
-
+	return FLAG_IS_SET(_flags, kHasLocationData);
+}
 
 typedef float (*tAccessor)(id, SEL);
 
@@ -4589,22 +4270,22 @@
 	tInterpData* data = (tInterpData*)malloc(sizeof(tInterpData)*(limit + 1));
 	NSEnumerator* enumer = [goodPoints objectEnumerator];
 	TrackPoint* pt = [gpts objectAtIndex:0];
-	float currentTime = [pt activeTimeDelta];
+	float currentTime = [pt _activeTimeDelta];
 	tAccessor ysel = (tAccessor)[TrackPoint instanceMethodForSelector:ptSel];
 	int ptIndex = 0;
 	TrackPoint* nextPt = [enumer nextObject];
-    NSTimeInterval nextPtTime =  pt ? [pt activeTimeDelta] : 0;
+    NSTimeInterval nextPtTime =  pt ? [pt _activeTimeDelta] : 0;
 	for (int i=0; i<=limit; i++)
 	{
-        nextPtTime = nextPt ? [nextPt activeTimeDelta] : nextPtTime;
+        nextPtTime = nextPt ? [nextPt _activeTimeDelta] : nextPtTime;
 		while ((currentTime >= nextPtTime) && nextPt)
 		{
 			pt = nextPt;
 			++ptIndex;
 			nextPt = [enumer nextObject];
-			nextPtTime = [nextPt activeTimeDelta];
-		}
-		NSTimeInterval curPtTime = [pt activeTimeDelta];
+			nextPtTime = [nextPt _activeTimeDelta];
+		}
+		NSTimeInterval curPtTime = [pt _activeTimeDelta];
 		float val = ysel(pt, nil);
 		float nextPtVal = val;
 		if (nextPtTime > curPtTime)
@@ -4620,14 +4301,12 @@
 	return data;
 }
 
-
 -(tPeakIntervalData*) getPID:(tPeakDataType)ty intervalIndex:(int)pi
 {
 	int np = [Utils numPeakIntervals];
 	tPeakIntervalData* pid = (tPeakIntervalData*)&peakIntervalData[(ty * np) + pi];
 	return pid;
 }
-
 
 -(void)setPeakForIntervalType:(tPeakDataType)ty intervalIndex:(int)pi value:(float)v atActiveTime:(NSTimeInterval)at
 {
@@ -4636,7 +4315,6 @@
 	pid->value = v;
 	pid->activeTime = at;
 }
-
 
 -(float)peakForIntervalType:(tPeakDataType)ty intervalIndex:(int)pi peakStartTime:(NSTimeInterval*)pst startingGoodPointIndex:(int*)sgpi
 {
@@ -4648,7 +4326,6 @@
 	return pid->value;
 }
 
-
 -(void)updatePeakForInterval:(tPeakDataType)ty intervalIndex:(int)pi value:(float)v atActiveTime:(NSTimeInterval)at startingGoodPoint:(int)gpidx
 {
 	tPeakIntervalData* pid = [self getPID:ty
@@ -4661,7 +4338,6 @@
 		pid->startingGoodPointIndex = gpidx;
 	}
 }
-
 
 -(void)calcPeaksForType:(tPeakDataType)pdt dataSel:(SEL)dsel
 {
@@ -4691,7 +4367,6 @@
 	}
 }
 
-
 -(void)calcPeaks
 {
 	if (!peakIntervalData)
@@ -4703,14 +4378,13 @@
 		{
 			for (int dt=0; dt<numPeakDataTypes; dt++)
 			{
-				if ((dt == kPDT_Power) && ([self hasDevicePower] || (FLAG_IS_SET(flags, kPowerDataCalculatedOrZeroed)))) 
+				if ((dt == kPDT_Power) && ([self hasDevicePower] || (FLAG_IS_SET(_flags, kPowerDataCalculatedOrZeroed)))) 
 					[self calcPeaksForType:kPDT_Power
 								   dataSel:@selector(power)];
 			}
 		}
 	}
 }
-
 
 //------------------------------------------------------------------------------
 
@@ -4726,7 +4400,6 @@
 	kKeyword2,
 };   
 
-
 -(NSString*) formatDeltaIntervalAsString:(NSTimeInterval)delta
 {
 	int hours = (int)delta/3600;
@@ -4735,16 +4408,13 @@
 	return [NSString stringWithFormat:@"%02d:%02d:%02d", hours, mins, secs];
 }
 
-
-
-
 -(NSString*) buildTextOutput:(char)sep
 {
 	NSMutableString* s = [NSMutableString stringWithCapacity:4000];
 	int timeFormat = [Utils intFromDefaults:RCBDefaultTimeFormat];
 	NSString* dt;
-	NSDate* startTime = [self creationTime];
-	NSTimeZone* tz = [NSTimeZone timeZoneForSecondsFromGMT:[self secondsFromGMT]];
+	NSDate* startTime = [self _creationTime];
+	NSTimeZone* tz = [NSTimeZone timeZoneForSecondsFromGMT:[self _secondsFromGMT]];
 	if (timeFormat == 0)
     {
 #if 0
@@ -4794,13 +4464,13 @@
 		TrackPoint* point = [pts objectAtIndex:p];
 		if (point != nil)
 		{
-			//[s appendString:[self formatDateIntervalAsString:[point date] startDate:[track creationTime]]];
+			//[s appendString:[self formatDateIntervalAsString:[point date] startDate:[track _creationTime]]];
 			[s appendString:[self formatDeltaIntervalAsString:[point wallClockDelta]]];
 			[s appendString:[NSString stringWithFormat:@"%c", sep]];
-			//[s appendString:[self formatDateIntervalAsString:[point activeTime] startDate:[track creationTime]]];
-			[s appendString:[self formatDeltaIntervalAsString:[point activeTimeDelta]]]      ;
+			//[s appendString:[self formatDateIntervalAsString:[point activeTime] startDate:[track _creationTime]]];
+			[s appendString:[self formatDeltaIntervalAsString:[point _activeTimeDelta]]]      ;
 			[s appendString:[NSString stringWithFormat:@"%c", sep]];
-			[s appendString:[NSString stringWithFormat:@"%1.2f",[Utils convertDistanceValue:[point distance]]]];
+			[s appendString:[NSString stringWithFormat:@"%1.2f",[Utils convertDistanceValue:[point _distance]]]];
 			[s appendString:[NSString stringWithFormat:@"%c", sep]];
 			[s appendString:[NSString stringWithFormat:@"%1.1f",[Utils convertSpeedValue:[point speed]]]];
 			[s appendString:[NSString stringWithFormat:@"%c", sep]];
@@ -4823,87 +4493,66 @@
 	return s;
 }
 
-
 -(BOOL)uploadToMobile
 {
-	return FLAG_IS_SET(flags, kUploadToMobile);
-}
-
+	return FLAG_IS_SET(_flags, kUploadToMobile);
+}
 
 -(void)setUploadToMobile:(BOOL)up
 {
 	if (up)
 	{
-		SET_FLAG(flags, kUploadToMobile);
+		SET_FLAG(_flags, kUploadToMobile);
 	}
 	else
 	{
-		CLEAR_FLAG(flags, kUploadToMobile);
-	}
-}
-
-
+		CLEAR_FLAG(_flags, kUploadToMobile);
+	}
+}
 
 //--------------------------------------------------------------------------------
 //---- OverrideData methods
 
 - (void) setOverrideValue:(tStatType)stat index:(int)idx value:(float)v
 {
-	[overrideData setValue:stat
+	[_overrideData setValue:stat
 					 index:idx
 					 value:v];
 }
 
-
 - (float) overrideValue:(tStatType)stat index:(int)idx
 {
-    return [overrideData value:stat index:idx];
-}
-
+    return [_overrideData value:stat index:idx];
+}
 
 - (void) clearOverride:(tStatType)stat
 {
-	return [overrideData clearOverride:stat];
-}
-
+	return [_overrideData clearOverride:stat];
+}
 
 - (BOOL) isOverridden:(tStatType)stat
 {
-	return [overrideData isOverridden:stat];
-}
-
-- (OverrideData*) overrideData
-{
-    return overrideData;
-}
-
+	return [_overrideData isOverridden:stat];
+}
+
+- (OverrideData*) _overrideData
+{
+    return _overrideData;
+}
 
 //--------------------------------------------------------------------------------
 
 //--------------------------------------------------------------------------------
 //----- Animation control --------------------------------
 
-- (void) setAnimTime:(NSTimeInterval)at
-{
-   animTime = at;
-}
-
-
-- (NSTimeInterval) animTime
-{
-   return animTime;
-}
-
-- (void) setAnimIndex:(int)idx
-{
-   animIndex = idx;
-}
-
-
-- (int) animIndex
-{
-   return animIndex;
-}
-
+- (NSTimeInterval) _animTime
+{
+   return _animTime;
+}
+
+- (int) _animIndex
+{
+   return _animIndex;
+}
 
 @end
